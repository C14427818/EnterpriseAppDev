"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAlias = exports.simplify = exports.parse = undefined;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

exports.getAliasFromResolveInfo = getAliasFromResolveInfo;
exports.parseResolveInfo = parseResolveInfo;
exports.simplifyParsedResolveInfoFragmentWithType = simplifyParsedResolveInfoFragmentWithType;

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _values = require("graphql/execution/values");

var _graphql = require("graphql");

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphql-parse-resolve-info");

// Originally based on https://github.com/tjmehta/graphql-parse-fields

function getAliasFromResolveInfo(resolveInfo) {
  var asts = resolveInfo.fieldNodes || resolveInfo.fieldASTs;
  var alias = asts.reduce(function (alias, val) {
    if (!alias) {
      if (val.kind === "Field") {
        alias = val.alias ? val.alias.value : val.name && val.name.value;
      }
    }
    return alias;
  }, null);
  if (!alias) {
    throw new Error("Could not determine alias?!");
  }
  return alias;
}

function parseResolveInfo(resolveInfo) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs;

  var parentType = resolveInfo.parentType;

  if (!fieldNodes) {
    throw new Error("No fieldNodes provided!");
  }
  if (options.keepRoot == null) {
    options.keepRoot = false;
  }
  if (options.deep == null) {
    options.deep = true;
  }
  var tree = fieldTreeFromAST(fieldNodes, resolveInfo, undefined, options, parentType);
  if (!options.keepRoot) {
    var typeKey = firstKey(tree);
    if (!typeKey) {
      return null;
    }
    tree = tree[typeKey];
    var fieldKey = firstKey(tree);
    if (!fieldKey) {
      return null;
    }
    tree = tree[fieldKey];
  }
  return tree;
}

function getFieldFromAST(ast, parentType) {
  if (ast.kind === "Field") {
    var fieldNode = ast;
    var fieldName = fieldNode.name.value;
    if (!(parentType instanceof _graphql.GraphQLUnionType)) {
      var type = parentType;
      return type.getFields()[fieldName];
    } else {
      // XXX: TODO: Handle GraphQLUnionType
    }
  }
  return;
}

var iNum = 1;
function fieldTreeFromAST(inASTs, resolveInfo) {
  var initTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var parentType = arguments[4];
  var depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";

  var instance = iNum++;
  debug("%s[%d] Entering fieldTreeFromAST with parent type '%s'", depth, instance, parentType);
  var variableValues = resolveInfo.variableValues;

  var fragments = resolveInfo.fragments || {};
  var asts = Array.isArray(inASTs) ? inASTs : [inASTs];
  initTree[parentType.name] = initTree[parentType.name] || {};
  var outerDepth = depth;
  return asts.reduce(function (tree, selectionVal, idx) {
    var depth = `${outerDepth}  `;
    debug("%s[%d] Processing AST %d of %d; kind = %s", depth, instance, idx + 1, asts.length, selectionVal.kind);
    if (selectionVal.kind === "Field") {
      var val = selectionVal;
      var _name = val.name && val.name.value;
      var isReserved = _name && _name !== "__id" && _name.substr(0, 2) === "__";
      if (isReserved) {
        debug("%s[%d] IGNORING because field '%s' is reserved", depth, instance, _name);
      } else {
        var _alias = val.alias && val.alias.value ? val.alias.value : val.name.value;
        debug("%s[%d] Field '%s' (alias = '%s')", depth, instance, _name, _alias);
        var field = getFieldFromAST(val, parentType);
        if (!field) {
          return tree;
        }
        var fieldGqlType = (0, _graphql.getNamedType)(field.type);
        if (!fieldGqlType) {
          return tree;
        }
        var _args = (0, _values.getArgumentValues)(field, val, variableValues) || {};
        if (parentType.name && !tree[parentType.name][_alias]) {
          var newTreeRoot = {
            name: _name,
            alias: _alias,
            args: _args,
            fieldsByTypeName: (0, _graphql.isCompositeType)(fieldGqlType) ? {
              [fieldGqlType.name]: {}
            } : {}
          };
          tree[parentType.name][_alias] = newTreeRoot;
        }
        var selectionSet = val.selectionSet;
        if (selectionSet != null && options.deep && (0, _graphql.isCompositeType)(fieldGqlType)) {
          var newParentType = fieldGqlType;
          debug("%s[%d] Recursing into subfields", depth, instance);
          fieldTreeFromAST(selectionSet.selections, resolveInfo, tree[parentType.name][_alias].fieldsByTypeName, options, newParentType, `${depth}  `);
        } else {
          // No fields to add
          debug("%s[%d] Exiting (no fields to add)", depth, instance);
        }
      }
    } else if (selectionVal.kind === "FragmentSpread" && options.deep) {
      var _val = selectionVal;
      var _name2 = _val.name && _val.name.value;
      debug("%s[%d] Fragment spread '%s'", depth, instance, _name2);
      var fragment = fragments[_name2];
      (0, _assert2.default)(fragment, 'unknown fragment "' + _name2 + '"');
      var fragmentType = parentType;
      if (fragment.typeCondition) {
        fragmentType = getType(resolveInfo, fragment.typeCondition);
      }
      if (fragmentType && (0, _graphql.isCompositeType)(fragmentType)) {
        var _newParentType = fragmentType;
        fieldTreeFromAST(fragment.selectionSet.selections, resolveInfo, tree, options, _newParentType, `${depth}  `);
      }
    } else if (selectionVal.kind === "InlineFragment" && options.deep) {
      var _val2 = selectionVal;
      var _fragment = _val2;
      var _fragmentType = parentType;
      if (_fragment.typeCondition) {
        _fragmentType = getType(resolveInfo, _fragment.typeCondition);
      }
      debug("%s[%d] Inline fragment (parent = '%s', type = '%s')", depth, instance, parentType, _fragmentType);
      if (_fragmentType && (0, _graphql.isCompositeType)(_fragmentType)) {
        var _newParentType2 = _fragmentType;
        fieldTreeFromAST(_fragment.selectionSet.selections, resolveInfo, tree, options, _newParentType2, `${depth}  `);
      }
    } else {
      debug("%s[%d] IGNORING because kind '%s' not understood", depth, instance, selectionVal.kind);
    }
    // Ref: https://github.com/postgraphql/postgraphql/pull/342/files#diff-d6702ec9fed755c88b9d70b430fda4d8R148
    return tree;
  }, initTree);
}

function firstKey(obj) {
  for (var key in obj) {
    return key;
  }
}

function getType(resolveInfo, typeCondition) {
  var schema = resolveInfo.schema;
  var kind = typeCondition.kind,
      name = typeCondition.name;

  if (kind === "NamedType") {
    var typeName = name.value;
    return schema.getType(typeName);
  }
}

function simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, Type) {
  var fieldsByTypeName = parsedResolveInfoFragment.fieldsByTypeName;

  var fields = {};
  var StrippedType = (0, _graphql.getNamedType)(Type);
  if ((0, _graphql.isCompositeType)(StrippedType)) {
    (0, _assign2.default)(fields, fieldsByTypeName[StrippedType.name]);
    if (StrippedType instanceof _graphql.GraphQLObjectType) {
      var ObjectType = StrippedType;
      // GraphQL ensures that the subfields cannot clash, so it's safe to simply overwrite them
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(ObjectType.getInterfaces()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var Interface = _step.value;

          (0, _assign2.default)(fields, fieldsByTypeName[Interface.name]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }
  return (0, _assign2.default)({}, parsedResolveInfoFragment, {
    fields
  });
}

var parse = exports.parse = parseResolveInfo;
var simplify = exports.simplify = simplifyParsedResolveInfoFragmentWithType;
var getAlias = exports.getAlias = getAliasFromResolveInfo;
//# sourceMappingURL=index.js.map