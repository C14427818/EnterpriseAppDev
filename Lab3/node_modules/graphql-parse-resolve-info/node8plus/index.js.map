{"version":3,"sources":["../src/index.js"],"names":["getAliasFromResolveInfo","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","debug","resolveInfo","asts","fieldNodes","fieldASTs","alias","reduce","val","kind","value","name","Error","options","parentType","keepRoot","deep","tree","fieldTreeFromAST","undefined","typeKey","firstKey","fieldKey","getFieldFromAST","ast","fieldNode","fieldName","type","getFields","iNum","inASTs","initTree","depth","instance","variableValues","fragments","Array","isArray","outerDepth","selectionVal","idx","length","isReserved","substr","field","fieldGqlType","args","newTreeRoot","fieldsByTypeName","selectionSet","newParentType","selections","fragment","fragmentType","typeCondition","getType","obj","key","schema","typeName","parsedResolveInfoFragment","Type","fields","StrippedType","ObjectType","Interface","getInterfaces","parse","simplify","getAlias"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\n\nimport assert from \"assert\";\nimport { getArgumentValues } from \"graphql/execution/values\";\nimport {\n  getNamedType,\n  isCompositeType,\n  GraphQLObjectType,\n  GraphQLUnionType,\n} from \"graphql\";\nimport debugFactory from \"debug\";\n\nimport type {\n  GraphQLResolveInfo,\n  GraphQLField,\n  GraphQLCompositeType,\n  GraphQLInterfaceType,\n  GraphQLType,\n} from \"graphql/type/definition\";\n\nimport type {\n  ASTNode,\n  FieldNode,\n  SelectionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n} from \"graphql/language/ast\";\n\nexport type FieldsByTypeName = {\n  [string]: {\n    [string]: ResolveTree,\n  },\n};\n\nexport type ResolveTree = {\n  name: string,\n  alias: string,\n  args: {\n    [string]: mixed,\n  },\n  fieldsByTypeName: FieldsByTypeName,\n};\n\nconst debug = debugFactory(\"graphql-parse-resolve-info\");\n\n// Originally based on https://github.com/tjmehta/graphql-parse-fields\n\nexport function getAliasFromResolveInfo(\n  resolveInfo: GraphQLResolveInfo\n): string {\n  const asts = resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n  const alias = asts.reduce(function(alias, val) {\n    if (!alias) {\n      if (val.kind === \"Field\") {\n        alias = val.alias ? val.alias.value : val.name && val.name.value;\n      }\n    }\n    return alias;\n  }, null);\n  if (!alias) {\n    throw new Error(\"Could not determine alias?!\");\n  }\n  return alias;\n}\n\nexport function parseResolveInfo(\n  resolveInfo: GraphQLResolveInfo,\n  options: { keepRoot?: boolean, deep?: boolean } = {}\n): ResolveTree | FieldsByTypeName | null | void {\n  const fieldNodes: $ReadOnlyArray<FieldNode> =\n    resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n\n  const { parentType } = resolveInfo;\n  if (!fieldNodes) {\n    throw new Error(\"No fieldNodes provided!\");\n  }\n  if (options.keepRoot == null) {\n    options.keepRoot = false;\n  }\n  if (options.deep == null) {\n    options.deep = true;\n  }\n  let tree = fieldTreeFromAST(\n    fieldNodes,\n    resolveInfo,\n    undefined,\n    options,\n    parentType\n  );\n  if (!options.keepRoot) {\n    const typeKey = firstKey(tree);\n    if (!typeKey) {\n      return null;\n    }\n    tree = tree[typeKey];\n    const fieldKey = firstKey(tree);\n    if (!fieldKey) {\n      return null;\n    }\n    tree = tree[fieldKey];\n  }\n  return tree;\n}\n\nfunction getFieldFromAST(\n  ast: ASTNode,\n  parentType: GraphQLCompositeType\n): ?GraphQLField<*, *> {\n  if (ast.kind === \"Field\") {\n    const fieldNode: FieldNode = ast;\n    const fieldName = fieldNode.name.value;\n    if (!(parentType instanceof GraphQLUnionType)) {\n      const type: GraphQLObjectType | GraphQLInterfaceType = parentType;\n      return type.getFields()[fieldName];\n    } else {\n      // XXX: TODO: Handle GraphQLUnionType\n    }\n  }\n  return;\n}\n\nlet iNum = 1;\nfunction fieldTreeFromAST<T: SelectionNode>(\n  inASTs: $ReadOnlyArray<T> | T,\n  resolveInfo: GraphQLResolveInfo,\n  initTree: FieldsByTypeName = {},\n  options = {},\n  parentType: GraphQLCompositeType,\n  depth = \"\"\n): FieldsByTypeName {\n  const instance = iNum++;\n  debug(\n    \"%s[%d] Entering fieldTreeFromAST with parent type '%s'\",\n    depth,\n    instance,\n    parentType\n  );\n  let { variableValues } = resolveInfo;\n  const fragments = resolveInfo.fragments || {};\n  const asts: $ReadOnlyArray<T> = Array.isArray(inASTs) ? inASTs : [inASTs];\n  initTree[parentType.name] = initTree[parentType.name] || {};\n  const outerDepth = depth;\n  return asts.reduce(function(tree, selectionVal: SelectionNode, idx) {\n    const depth = `${outerDepth}  `;\n    debug(\n      \"%s[%d] Processing AST %d of %d; kind = %s\",\n      depth,\n      instance,\n      idx + 1,\n      asts.length,\n      selectionVal.kind\n    );\n    if (selectionVal.kind === \"Field\") {\n      const val: FieldNode = selectionVal;\n      const name = val.name && val.name.value;\n      const isReserved = name && name !== \"__id\" && name.substr(0, 2) === \"__\";\n      if (isReserved) {\n        debug(\n          \"%s[%d] IGNORING because field '%s' is reserved\",\n          depth,\n          instance,\n          name\n        );\n      } else {\n        const alias: string =\n          val.alias && val.alias.value ? val.alias.value : val.name.value;\n        debug(\"%s[%d] Field '%s' (alias = '%s')\", depth, instance, name, alias);\n        const field = getFieldFromAST(val, parentType);\n        if (!field) {\n          return tree;\n        }\n        const fieldGqlType = getNamedType(field.type);\n        if (!fieldGqlType) {\n          return tree;\n        }\n        const args = getArgumentValues(field, val, variableValues) || {};\n        if (parentType.name && !tree[parentType.name][alias]) {\n          const newTreeRoot: ResolveTree = {\n            name,\n            alias,\n            args,\n            fieldsByTypeName: isCompositeType(fieldGqlType)\n              ? {\n                  [fieldGqlType.name]: {},\n                }\n              : {},\n          };\n          tree[parentType.name][alias] = newTreeRoot;\n        }\n        const selectionSet = val.selectionSet;\n        if (\n          selectionSet != null &&\n          options.deep &&\n          isCompositeType(fieldGqlType)\n        ) {\n          const newParentType: GraphQLCompositeType = fieldGqlType;\n          debug(\"%s[%d] Recursing into subfields\", depth, instance);\n          fieldTreeFromAST(\n            selectionSet.selections,\n            resolveInfo,\n            tree[parentType.name][alias].fieldsByTypeName,\n            options,\n            newParentType,\n            `${depth}  `\n          );\n        } else {\n          // No fields to add\n          debug(\"%s[%d] Exiting (no fields to add)\", depth, instance);\n        }\n      }\n    } else if (selectionVal.kind === \"FragmentSpread\" && options.deep) {\n      const val: FragmentSpreadNode = selectionVal;\n      const name = val.name && val.name.value;\n      debug(\"%s[%d] Fragment spread '%s'\", depth, instance, name);\n      const fragment = fragments[name];\n      assert(fragment, 'unknown fragment \"' + name + '\"');\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else if (selectionVal.kind === \"InlineFragment\" && options.deep) {\n      const val: InlineFragmentNode = selectionVal;\n      const fragment = val;\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      debug(\n        \"%s[%d] Inline fragment (parent = '%s', type = '%s')\",\n        depth,\n        instance,\n        parentType,\n        fragmentType\n      );\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else {\n      debug(\n        \"%s[%d] IGNORING because kind '%s' not understood\",\n        depth,\n        instance,\n        selectionVal.kind\n      );\n    }\n    // Ref: https://github.com/graphile/postgraphile/pull/342/files#diff-d6702ec9fed755c88b9d70b430fda4d8R148\n    return tree;\n  }, initTree);\n}\n\nfunction firstKey(obj) {\n  for (const key in obj) {\n    return key;\n  }\n}\n\nfunction getType(resolveInfo, typeCondition) {\n  const { schema } = resolveInfo;\n  const { kind, name } = typeCondition;\n  if (kind === \"NamedType\") {\n    const typeName = name.value;\n    return schema.getType(typeName);\n  }\n}\n\nexport function simplifyParsedResolveInfoFragmentWithType(\n  parsedResolveInfoFragment: ResolveTree,\n  Type: GraphQLType\n) {\n  const { fieldsByTypeName } = parsedResolveInfoFragment;\n  const fields = {};\n  const StrippedType = getNamedType(Type);\n  if (isCompositeType(StrippedType)) {\n    Object.assign(fields, fieldsByTypeName[StrippedType.name]);\n    if (StrippedType instanceof GraphQLObjectType) {\n      const ObjectType: GraphQLObjectType = StrippedType;\n      // GraphQL ensures that the subfields cannot clash, so it's safe to simply overwrite them\n      for (const Interface of ObjectType.getInterfaces()) {\n        Object.assign(fields, fieldsByTypeName[Interface.name]);\n      }\n    }\n  }\n  return Object.assign({}, parsedResolveInfoFragment, {\n    fields,\n  });\n}\n\nexport const parse = parseResolveInfo;\nexport const simplify = simplifyParsedResolveInfoFragmentWithType;\nexport const getAlias = getAliasFromResolveInfo;\n"]}