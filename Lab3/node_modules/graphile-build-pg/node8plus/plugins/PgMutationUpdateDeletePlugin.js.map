{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","base64Decode","str","Buffer","String","toString","PgMutationUpdateDeletePlugin","builder","pgInflection","inflection","pgDisableDefaultMutations","hook","fields","build","scope","isRootMutation","fieldWithHooks","newWithHooks","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getNodeType","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","reduce","outerMemo","mode","class","filter","table","namespace","isUpdatable","isDeletable","memo","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","input","condition","context","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableName","attribute","attr","classId","forEach","fieldName","column","val","push","length","query","join","map","col","i","fragment","modifiedRowAlias","row","result","rows","e","Error","clientMutationId","data","uniqueConstraints","constraint","con","attributes","sort","a","b","num","Table","tableTypeName","TablePatch","patchType","description","recurseDataGeneratorsForField","deletedNodeIdFieldName","singular","resolve","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","__identifiers","isPgMutationPayloadDeletedNodeIdField","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributeNums","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","isMutationInput","args","parent","nodeId","alias","identifiers","JSON","parse","NodeTypeByAlias","key","idx","isPgNodeMutation","pgFieldIntrospection","keys","every","_","simpleKeys","k","schema","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys"],"mappings":"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","file":"PgMutationUpdateDeletePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\nimport camelCase from \"lodash/camelCase\";\nimport pluralize from \"pluralize\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\nconst base64Decode = str => new Buffer(String(str), \"base64\").toString(\"utf8\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgInflection: inflection, pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, { scope: { isRootMutation }, fieldWithHooks }) => {\n      const {\n        newWithHooks,\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        fieldDataGeneratorsByType,\n        extend,\n        parseResolveInfo,\n        getTypeByName,\n        gql2pg,\n        pgGetGqlTypeByTypeId,\n        pgGetGqlInputTypeByTypeId,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        getNodeType,\n        graphql: {\n          GraphQLNonNull,\n          GraphQLInputObjectType,\n          GraphQLString,\n          GraphQLObjectType,\n          GraphQLID,\n        },\n        pgColumnFilter,\n      } = build;\n      if (!isRootMutation) {\n        return fields;\n      }\n      return extend(\n        fields,\n        [\"update\", \"delete\"].reduce(\n          (outerMemo, mode) =>\n            introspectionResultsByKind.class\n              .filter(table => !!table.namespace)\n              .filter(\n                table =>\n                  (mode === \"update\" && table.isUpdatable) ||\n                  (mode === \"delete\" && table.isDeletable)\n              )\n              .reduce((memo, table) => {\n                const TableType = pgGetGqlTypeByTypeId(table.type.id);\n                async function commonCodeRenameMe(\n                  pgClient,\n                  resolveInfo,\n                  getDataFromParsedResolveInfoFragment,\n                  PayloadType,\n                  input,\n                  condition,\n                  context\n                ) {\n                  const parsedResolveInfoFragment = parseResolveInfo(\n                    resolveInfo\n                  );\n                  const resolveData = getDataFromParsedResolveInfoFragment(\n                    parsedResolveInfoFragment,\n                    PayloadType\n                  );\n\n                  const sqlTypeIdentifier = sql.identifier(\n                    table.namespace.name,\n                    table.name\n                  );\n\n                  let sqlMutationQuery;\n                  if (mode === \"update\") {\n                    const sqlColumns = [];\n                    const sqlValues = [];\n                    const inputData =\n                      input[\n                        inflection.patchField(\n                          inflection.tableName(table.name, table.namespace.name)\n                        )\n                      ];\n                    introspectionResultsByKind.attribute\n                      .filter(attr => attr.classId === table.id)\n                      .filter(attr => pgColumnFilter(attr, build, context))\n                      .forEach(attr => {\n                        const fieldName = inflection.column(\n                          attr.name,\n                          table.name,\n                          table.namespace.name\n                        );\n                        if (\n                          fieldName in\n                          inputData /* Because we care about null! */\n                        ) {\n                          const val = inputData[fieldName];\n                          sqlColumns.push(sql.identifier(attr.name));\n                          sqlValues.push(gql2pg(val, attr.type));\n                        }\n                      });\n                    if (sqlColumns.length === 0) {\n                      return null;\n                    }\n                    sqlMutationQuery = sql.query`\n                      update ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )} set ${sql.join(\n                      sqlColumns.map(\n                        (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                      ),\n                      \", \"\n                    )}\n                      where ${condition}\n                      returning *`;\n                  } else {\n                    sqlMutationQuery = sql.query`\n                      delete from ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )}\n                      where ${condition}\n                      returning *`;\n                  }\n\n                  const modifiedRowAlias = sql.identifier(Symbol());\n                  const query = queryFromResolveData(\n                    modifiedRowAlias,\n                    modifiedRowAlias,\n                    resolveData,\n                    {}\n                  );\n                  let row;\n                  try {\n                    await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                    const result = await viaTemporaryTable(\n                      pgClient,\n                      sqlTypeIdentifier,\n                      sqlMutationQuery,\n                      modifiedRowAlias,\n                      query\n                    );\n                    row = result.rows[0];\n                    await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                  } catch (e) {\n                    await pgClient.query(\n                      \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                    );\n                    throw e;\n                  }\n                  if (!row) {\n                    throw new Error(\n                      `No values were ${mode}d in collection '${pluralize(\n                        table.name\n                      )}' because no values were found.`\n                    );\n                  }\n                  return {\n                    clientMutationId: input.clientMutationId,\n                    data: row,\n                  };\n                }\n                if (TableType) {\n                  const uniqueConstraints = introspectionResultsByKind.constraint\n                    .filter(con => con.classId === table.id)\n                    .filter(con => con.type === \"u\" || con.type === \"p\");\n                  const attributes = introspectionResultsByKind.attribute\n                    .filter(attr => attr.classId === table.id)\n                    .sort((a, b) => a.num - b.num);\n                  const Table = pgGetGqlTypeByTypeId(table.type.id);\n                  const tableTypeName = Table.name;\n                  const TablePatch = getTypeByName(\n                    inflection.patchType(Table.name)\n                  );\n                  const PayloadType = newWithHooks(\n                    GraphQLObjectType,\n                    {\n                      name: inflection[\n                        mode === \"delete\"\n                          ? \"deletePayloadType\"\n                          : \"updatePayloadType\"\n                      ](table.name, table.namespace.name),\n                      description: `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                      fields: ({\n                        recurseDataGeneratorsForField,\n                        fieldWithHooks,\n                      }) => {\n                        const tableName = inflection.tableName(\n                          table.name,\n                          table.namespace.name\n                        );\n                        recurseDataGeneratorsForField(tableName);\n                        // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                        const deletedNodeIdFieldName = camelCase(\n                          `deleted-${pluralize.singular(table.name)}-id`\n                        );\n                        return Object.assign(\n                          {\n                            clientMutationId: {\n                              description:\n                                \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                              type: GraphQLString,\n                            },\n                            [tableName]: {\n                              description: `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                              type: Table,\n                              resolve(data) {\n                                return data.data;\n                              },\n                            },\n                          },\n                          mode === \"delete\"\n                            ? {\n                                [deletedNodeIdFieldName]: fieldWithHooks(\n                                  deletedNodeIdFieldName,\n                                  ({ addDataGenerator }) => {\n                                    const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                      TableType\n                                    );\n\n                                    const gens =\n                                      fieldDataGeneratorsByTableType &&\n                                      fieldDataGeneratorsByTableType[\n                                        nodeIdFieldName\n                                      ];\n                                    if (gens) {\n                                      gens.forEach(gen =>\n                                        addDataGenerator(gen)\n                                      );\n                                    }\n                                    return {\n                                      type: GraphQLID,\n                                      resolve(data) {\n                                        return (\n                                          data.data.__identifiers &&\n                                          getNodeIdForTypeAndIdentifiers(\n                                            Table,\n                                            ...data.data.__identifiers\n                                          )\n                                        );\n                                      },\n                                    };\n                                  },\n                                  {\n                                    isPgMutationPayloadDeletedNodeIdField: true,\n                                  }\n                                ),\n                              }\n                            : null\n                        );\n                      },\n                    },\n                    {\n                      isMutationPayload: true,\n                      isPgUpdatePayloadType: mode === \"update\",\n                      isPgDeletePayloadType: mode === \"delete\",\n                      pgIntrospection: table,\n                    }\n                  );\n\n                  // NodeId\n                  if (nodeIdFieldName) {\n                    const primaryKeyConstraint = introspectionResultsByKind.constraint\n                      .filter(con => con.classId === table.id)\n                      .filter(con => con.type === \"p\")[0];\n                    if (!primaryKeyConstraint) {\n                      return memo;\n                    }\n                    const primaryKeys =\n                      primaryKeyConstraint &&\n                      primaryKeyConstraint.keyAttributeNums.map(\n                        num => attributes.filter(attr => attr.num === num)[0]\n                      );\n                    const fieldName = inflection[\n                      mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                    ](table.name, table.namespace.name);\n                    const InputType = newWithHooks(\n                      GraphQLInputObjectType,\n                      {\n                        description: `All input for the \\`${fieldName}\\` mutation.`,\n                        name: inflection[\n                          mode === \"update\"\n                            ? \"updateNodeInputType\"\n                            : \"deleteNodeInputType\"\n                        ](table.name, table.namespace.name),\n                        fields: Object.assign(\n                          {\n                            clientMutationId: {\n                              description:\n                                \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                              type: GraphQLString,\n                            },\n                            [nodeIdFieldName]: {\n                              description: `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                              type: new GraphQLNonNull(GraphQLID),\n                            },\n                          },\n                          mode === \"update\"\n                            ? {\n                                [inflection.patchField(\n                                  inflection.tableName(\n                                    table.name,\n                                    table.namespace.name\n                                  )\n                                )]: {\n                                  description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  type: new GraphQLNonNull(TablePatch),\n                                },\n                              }\n                            : null\n                        ),\n                      },\n                      {\n                        isPgUpdateInputType: mode === \"update\",\n                        isPgUpdateNodeInputType: mode === \"update\",\n                        isPgDeleteInputType: mode === \"delete\",\n                        isPgDeleteNodeInputType: mode === \"delete\",\n                        pgInflection: table,\n                        isMutationInput: true,\n                      }\n                    );\n\n                    memo[fieldName] = fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            const nodeId = input[nodeIdFieldName];\n                            try {\n                              const [alias, ...identifiers] = JSON.parse(\n                                base64Decode(nodeId)\n                              );\n                              const NodeTypeByAlias = getNodeType(alias);\n                              if (NodeTypeByAlias !== TableType) {\n                                throw new Error(\"Mismatched type\");\n                              }\n                              if (identifiers.length !== primaryKeys.length) {\n                                throw new Error(\"Invalid ID\");\n                              }\n\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                input,\n                                sql.fragment`(${sql.join(\n                                  primaryKeys.map(\n                                    (key, idx) =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        identifiers[idx],\n                                        key.type\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context\n                              );\n                            } catch (e) {\n                              debug(e);\n                              return null;\n                            }\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: true,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    );\n                  }\n\n                  // Unique\n                  uniqueConstraints.forEach(constraint => {\n                    const keys = constraint.keyAttributeNums.map(\n                      num => attributes.filter(attr => attr.num === num)[0]\n                    );\n                    if (!keys.every(_ => _)) {\n                      throw new Error(\n                        \"Consistency error: could not find an attribute!\"\n                      );\n                    }\n                    const simpleKeys = keys.map(k => ({\n                      column: k.name,\n                      table: k.class.name,\n                      schema: k.class.namespace.name,\n                    }));\n                    const fieldName = inflection[\n                      mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                    ](simpleKeys, table.name, table.namespace.name);\n                    const InputType = newWithHooks(\n                      GraphQLInputObjectType,\n                      {\n                        description: `All input for the \\`${fieldName}\\` mutation.`,\n                        name: inflection[\n                          mode === \"update\"\n                            ? \"updateByKeysInputType\"\n                            : \"deleteByKeysInputType\"\n                        ](simpleKeys, table.name, table.namespace.name),\n                        fields: Object.assign(\n                          {\n                            clientMutationId: {\n                              type: GraphQLString,\n                            },\n                          },\n                          mode === \"update\"\n                            ? {\n                                [inflection.patchField(\n                                  inflection.tableName(\n                                    table.name,\n                                    table.namespace.name\n                                  )\n                                )]: {\n                                  description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  type: new GraphQLNonNull(TablePatch),\n                                },\n                              }\n                            : null,\n                          keys.reduce((memo, key) => {\n                            memo[\n                              inflection.column(\n                                key.name,\n                                key.class.name,\n                                key.class.namespace.name\n                              )\n                            ] = {\n                              description: key.description,\n                              type: new GraphQLNonNull(\n                                pgGetGqlInputTypeByTypeId(key.typeId)\n                              ),\n                            };\n                            return memo;\n                          }, {})\n                        ),\n                      },\n                      {\n                        isPgUpdateInputType: mode === \"update\",\n                        isPgUpdateByKeysInputType: mode === \"update\",\n                        isPgDeleteInputType: mode === \"delete\",\n                        isPgDeleteByKeysInputType: mode === \"delete\",\n                        pgInflection: table,\n                        pgKeys: keys,\n                        isMutationInput: true,\n                      }\n                    );\n\n                    memo[fieldName] = fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            return commonCodeRenameMe(\n                              pgClient,\n                              resolveInfo,\n                              getDataFromParsedResolveInfoFragment,\n                              PayloadType,\n                              input,\n                              sql.fragment`(${sql.join(\n                                keys.map(\n                                  key =>\n                                    sql.fragment`${sql.identifier(\n                                      key.name\n                                    )} = ${gql2pg(\n                                      input[\n                                        inflection.column(\n                                          key.name,\n                                          key.class.name,\n                                          key.class.namespace.name\n                                        )\n                                      ],\n                                      key.type\n                                    )}`\n                                ),\n                                \") and (\"\n                              )})`,\n                              context\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: false,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    );\n                  });\n                }\n                return memo;\n              }, outerMemo),\n          {}\n        ),\n        `Adding default update/delete mutations to root Mutation type`\n      );\n    }\n  );\n}: Plugin);\n"]}