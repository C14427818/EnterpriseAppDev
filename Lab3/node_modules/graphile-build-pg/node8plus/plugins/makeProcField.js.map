{"version":3,"sources":["../../src/plugins/makeProcField.js"],"names":["makeProcField","debugSql","firstValue","obj","firstKey","k","fieldName","proc","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","getTypeByName","pgSql","sql","parseResolveInfo","getAliasFromResolveInfo","gql2pg","pg2gql","newWithHooks","pgInflection","inflection","pgStrictFunctions","strictFunctions","pgTweakFragmentForType","graphql","GraphQLNonNull","GraphQLList","GraphQLString","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","fieldWithHooks","computed","isMutation","getResultFieldName","gqlType","type","returnsSet","gqlNamedType","name","isPgArray","Error","sliceAmount","argNames","argTypeIds","slice","map","_","idx","argTypes","typeId","typeById","requiredArgCount","Math","max","length","argDefaultsNum","notNullArgCount","isStrict","argGqlTypes","Type","id","rawReturnType","returnTypeId","returnType","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","connectionTypeName","scalarFunctionConnection","namespace","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeMutationCall","parsedResolveInfoFragment","ReturnType","implicitArgs","args","rawArgs","input","sqlArgValues","haveNames","argIndex","argName","gqlArgName","argument","value","sqlValue","sqlArgName","identifier","unshift","fragment","join","makeQuery","sqlMutationQuery","functionAlias","resolveData","query","withPagination","withPaginationAsFields","asJson","addNullCase","innerQueryBuilder","select","pgQuery","queryBuilder","parentTableAlias","getTableAlias","alias","PayloadType","reduce","memo","resultFieldName","isNotVoid","String","functionPayloadType","description","functionName","fields","recurseDataGeneratorsForField","clientMutationId","resolve","data","isMutationPayload","InputType","functionInputType","isMutationInput","_args","_context","resolveInfo","v","pgClient","queryResult","intermediateIdentifier","isVoid","isPgClass","namespaceName","e","text","values","compile","enabled","rows","row","result"],"mappings":";;;;;;;;;;;;;;kBAqBwBA,a;;AApBxB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAMA,MAAMC,WAAW,qBAAa,uBAAb,CAAjB;AACA,MAAMC,aAAaC,OAAO;AACxB,MAAIC,QAAJ;AACA,OAAK,MAAMC,CAAX,IAAgBF,GAAhB,EAAqB;AACnBC,eAAWC,CAAX;AACD;AACD,SAAOF,IAAIC,QAAJ,CAAP;AACD,CAND;;AAQe,SAASJ,aAAT,CACbM,SADa,EAEbC,IAFa,EAGb;AACEC,gCAA8BC,0BADhC;AAEEC,sBAFF;AAGEC,2BAHF;AAIEC,eAJF;AAKEC,SAAOC,GALT;AAMEC,kBANF;AAOEC,yBAPF;AAQEC,QARF;AASEC,QATF;AAUEC,cAVF;AAWEC,gBAAcC,UAXhB;AAYEC,qBAAmBC,eAZrB;AAaEC,wBAbF;AAcEC,WAAS;AACPC,kBADO;AAEPC,eAFO;AAGPC,iBAHO;AAIPC,cAJO;AAKPC,gBALO;AAMPC,kBANO;AAOPC,qBAPO;AAQPC,0BARO;AASPC,gBATO;AAUPC;AAVO;AAdX,CAHa,EA8Bb;AACEC,gBADF;AAEEC,aAAW,KAFb;AAGEC,eAAa;AAHf,CA9Ba,EAuCb;AACA,WAASC,kBAAT,CAA4BC,OAA5B,EAAqCC,IAArC,EAA2CC,UAA3C,EAAuD;AACrD,UAAMC,eAAeT,aAAaM,OAAb,CAArB;AACA,QAAII,IAAJ;AACA,QAAID,iBAAiBd,UAArB,EAAiC;AAC/Be,aAAO,SAAP;AACD,KAFD,MAEO,IAAID,iBAAiBb,YAArB,EAAmC;AACxCc,aAAO,OAAP;AACD,KAFM,MAEA,IAAID,iBAAiBZ,cAArB,EAAqC;AAC1Ca,aAAO,SAAP;AACD,KAFM,MAEA,IAAID,iBAAiBf,aAArB,EAAoC;AACzCgB,aAAO,QAAP;AACD,KAFM,MAEA;AACLA,aAAO,yBAAUD,aAAaC,IAAvB,CAAP;AACD;AACD,WAAOF,cAAcD,KAAKI,SAAnB,GAA+B,yBAAUD,IAAV,CAA/B,GAAiDA,IAAxD;AACD;AACD,MAAIP,YAAYC,UAAhB,EAA4B;AAC1B,UAAM,IAAIQ,KAAJ,CAAU,uCAAV,CAAN;AACD;AACD,QAAMC,cAAcV,WAAW,CAAX,GAAe,CAAnC;AACA,QAAMW,WAAWzC,KAAK0C,UAAL,CACdC,KADc,CACRH,WADQ,EAEdI,GAFc,CAEV,CAACC,CAAD,EAAIC,GAAJ,KAAY9C,KAAKyC,QAAL,CAAcK,MAAMN,WAApB,KAAoC,EAFtC,CAAjB;AAGA,QAAMO,WAAW/C,KAAK0C,UAAL,CACdC,KADc,CACRH,WADQ,EAEdI,GAFc,CAEVI,UAAU9C,2BAA2B+C,QAA3B,CAAoCD,MAApC,CAFA,CAAjB;AAGA,QAAME,mBAAmBC,KAAKC,GAAL,CAAS,CAAT,EAAYX,SAASY,MAAT,GAAkBrD,KAAKsD,cAAnC,CAAzB;AACA,QAAMC,kBACJvD,KAAKwD,QAAL,IAAiBxC,eAAjB,GAAmCkC,gBAAnC,GAAsD,CADxD;AAEA,QAAMO,cAAcV,SAASH,GAAT,CAAa,CAACV,IAAD,EAAOY,GAAP,KAAe;AAC9C,UAAMY,OAAOtD,0BAA0B8B,KAAKyB,EAA/B,KAAsCtC,aAAnD;AACA,QAAIyB,OAAOS,eAAX,EAA4B;AAC1B,aAAOG,IAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAIvC,cAAJ,CAAmBuC,IAAnB,CAAP;AACD;AACF,GAPmB,CAApB;;AASA,QAAME,gBAAgB1D,2BAA2B+C,QAA3B,CAAoCjD,KAAK6D,YAAzC,CAAtB;AACA,QAAMC,aAAaF,cAActB,SAAd,GACfsB,cAAcG,aADC,GAEfH,aAFJ;AAGA,QAAMI,kBACJ9D,2BAA2B+D,SAA3B,CAAqCH,WAAWI,OAAhD,CADF;AAEA,MAAI,CAACJ,UAAL,EAAiB;AACf,UAAM,IAAIvB,KAAJ,CACH,iDAAgDvC,KAAKqC,IAAK,GADvD,CAAN;AAGD;AACD,MAAIH,IAAJ;AACA,QAAMiC,aAAa,EAAnB;AACA,QAAMC,mBAAmB,EAAzB;AACAD,aAAWE,oBAAX,GAAkCrE,IAAlC;AACAoE,mBAAiBE,eAAjB,GAAmCtE,IAAnC;AACA,MAAIuE,0BAA0B,KAA9B;AACA,QAAMC,YACJR,mBAAmB7D,qBAAqB6D,gBAAgB9B,IAAhB,CAAqByB,EAA1C,CADrB;;AAGA,QAAMc,cACHD,aAAa5C,gBAAgB4C,SAAhB,CAAd,IAA6C,KAD/C;AAEA,MAAIC,WAAJ,EAAiB;AACf,QAAIzE,KAAKmC,UAAT,EAAqB;AACnB,UAAIJ,UAAJ,EAAgB;AACdG,eAAO,IAAId,WAAJ,CAAgBoD,SAAhB,CAAP;AACD,OAFD,MAEO;AACL,cAAME,iBAAiBrE,cACrBS,WAAW6D,UAAX,CAAsBH,UAAUnC,IAAhC,CADqB,CAAvB;AAGA,YAAI,CAACqC,cAAL,EAAqB;AACnB,gBAAM,IAAInC,KAAJ,CACH,kCAAiCzB,WAAW6D,UAAX,CAChCH,UAAUnC,IADsB,CAEhC,UAASmC,UAAUnC,IAAK,oCAHtB,CAAN;AAKD;AACDH,eAAO,IAAIf,cAAJ,CAAmBuD,cAAnB,CAAP;AACAP,mBAAWS,mBAAX,GAAiC,IAAjC;AACD;AACDT,iBAAWU,yBAAX,GAAuCb,eAAvC;AACAI,uBAAiBU,oBAAjB,GAAwCd,eAAxC;AACD,KAnBD,MAmBO;AACL9B,aAAOsC,SAAP;AACA,UAAIZ,cAActB,SAAlB,EAA6B;AAC3BJ,eAAO,IAAId,WAAJ,CAAgBc,IAAhB,CAAP;AACD;AACDiC,iBAAWU,yBAAX,GAAuCb,eAAvC;AACAI,uBAAiBU,oBAAjB,GAAwCd,eAAxC;AACD;AACF,GA5BD,MA4BO;AACL,UAAMN,OAAOvD,qBAAqB2D,WAAWH,EAAhC,KAAuCtC,aAApD;AACA,QAAIrB,KAAKmC,UAAT,EAAqB;AACnB,YAAM4C,qBAAqBjE,WAAWkE,wBAAX,CACzBhF,KAAKqC,IADoB,EAEzBrC,KAAKiF,SAAL,CAAe5C,IAFU,CAA3B;AAIA,YAAMqC,iBAAiBrE,cAAc0E,kBAAd,CAAvB;AACA,UAAIL,cAAJ,EAAoB;AAClB,YAAI3C,UAAJ,EAAgB;AACd;AACAG,iBAAO,IAAId,WAAJ,CAAgBsC,IAAhB,CAAP;AACAa,oCAA0B,IAA1B;AACD,SAJD,MAIO;AACLrC,iBAAO,IAAIf,cAAJ,CAAmBuD,cAAnB,CAAP;AACAP,qBAAWS,mBAAX,GAAiC,IAAjC;AACD;AACF,OATD,MASO;AACLL,kCAA0B,IAA1B;AACArC,eAAO,IAAId,WAAJ,CAAgBsC,IAAhB,CAAP;AACD;AACF,KAnBD,MAmBO;AACLa,gCAA0B,IAA1B;AACArC,aAAOwB,IAAP;AACA,UAAIE,cAActB,SAAlB,EAA6B;AAC3BJ,eAAO,IAAId,WAAJ,CAAgBc,IAAhB,CAAP;AACD;AACF;AACF;AACD,SAAOL,eACL9B,SADK,EAEL,CAAC;AACCmF,oBADD;AAECC,wCAFD;AAGCC;AAHD,GAAD,KAIM;AACJ,QACEpF,KAAKmC,UAAL,IACA,CAACsC,WADD,IAEA,CAACF,uBAFD,IAGA,CAACxC,UAJH,EAKE;AACA;AACAqD,0BAAoB,SAASC,iBAAT,GAA6B;AAC/C,eAAO;AACLC,0BAAgB/E,IAAIgF,OAAJ,CAAY,SAAZ;AADX,SAAP;AAGD,OAJD;AAKD;AACD,aAASC,gBAAT,CACEC,yBADF,EAEEC,UAFF,EAGE,EAAEC,eAAe,EAAjB,KAAwB,EAH1B,EAIO;AACL,YAAM,EAAEC,MAAMC,UAAU,EAAlB,KAAyBJ,yBAA/B;AACA,YAAMG,OAAO7D,aAAa8D,QAAQC,KAArB,GAA6BD,OAA1C;AACA,YAAME,eAAe,EAArB;AACA,UAAIC,YAAY,IAAhB;AACA,WAAK,IAAIC,WAAWxD,SAASY,MAAT,GAAkB,CAAtC,EAAyC4C,YAAY,CAArD,EAAwDA,UAAxD,EAAoE;AAClE,cAAMC,UAAUzD,SAASwD,QAAT,CAAhB;AACA,cAAME,aAAarF,WAAWsF,QAAX,CAAoBF,OAApB,EAA6BD,QAA7B,CAAnB;AACA,cAAMI,QAAQT,KAAKO,UAAL,CAAd;AACA,cAAMG,WAAW5F,OAAO2F,KAAP,EAActD,SAASkD,QAAT,CAAd,CAAjB;AACA,YAAIA,WAAW,CAAX,GAAe/C,gBAAf,IAAmC8C,SAAnC,IAAgDK,SAAS,IAA7D,EAAmE;AACjE;AACA;AACD,SAHD,MAGO,IAAIJ,WAAW,CAAX,GAAe/C,gBAAf,IAAmC8C,SAAvC,EAAkD;AACvD,gBAAMO,aAAaL,UAAU3F,IAAIiG,UAAJ,CAAeN,OAAf,CAAV,GAAoC,IAAvD;AACA,cAAIK,UAAJ,EAAgB;AACdR,yBAAaU,OAAb,CAAqBlG,IAAImG,QAAS,GAAEH,UAAW,OAAMD,QAAS,EAA9D;AACD,WAFD,MAEO;AACLN,wBAAY,KAAZ;AACAD,yBAAaU,OAAb,CAAqBH,QAArB;AACD;AACF,SARM,MAQA;AACLP,uBAAaU,OAAb,CAAqBH,QAArB;AACD;AACF;AACD,aAAO/F,IAAImG,QAAS,GAAEnG,IAAIiG,UAAJ,CACpBxG,KAAKiF,SAAL,CAAe5C,IADK,EAEpBrC,KAAKqC,IAFe,CAGpB,IAAG9B,IAAIoG,IAAJ,CAAS,CAAC,GAAGhB,YAAJ,EAAkB,GAAGI,YAArB,CAAT,EAA6C,IAA7C,CAAmD,GAHxD;AAID;AACD,aAASa,SAAT,CACEnB,yBADF,EAEEC,UAFF,EAGEmB,gBAHF,EAIEC,aAJF,EAKE;AACA,YAAMC,cAAc5B,qCAClBM,yBADkB,EAElBC,UAFkB,CAApB;AAIA,YAAMsB,QAAQ,oCACZH,gBADY,EAEZC,aAFY,EAGZC,WAHY,EAIZ;AACEE,wBAAgB,CAAClF,UAAD,IAAe/B,KAAKmC,UADtC;AAEE+E,gCAAwB,CAACnF,UAAD,IAAe/B,KAAKmC,UAApB,IAAkC,CAACL,QAF7D;AAGEqF,gBAAQ,CAACnH,KAAKmC,UAAN,IAAoBL,QAApB,IAAgC,CAACyC,uBAH3C;AAIE6C,qBAAa,CAACpH,KAAKmC,UAAN,IAAoBsC;AAJnC,OAJY,EAUZ4C,qBAAqB;AACnB,YAAI,CAAC5C,WAAL,EAAkB;AAChB,cAAIT,eAAJ,EAAqB;AACnBqD,8BAAkBC,MAAlB,CACErG,uBACEV,IAAImG,QAAS,GAAEI,aAAc,EAD/B,EAEE9C,gBAAgB9B,IAFlB,CADF,EAKE,OALF;AAOD,WARD,MAQO;AACLmF,8BAAkBC,MAAlB,CACErG,uBACEV,IAAImG,QAAS,GAAEI,aAAc,IAAGA,aAAc,EADhD,EAEEhD,UAFF,CADF,EAKE,OALF;AAOD;AACF;AACF,OA9BW,CAAd;AAgCA,aAAOkD,KAAP;AACD;AACD,QAAIlF,QAAJ,EAAc;AACZoD,uBAAiB,CAACO,yBAAD,EAA4BC,UAA5B,KAA2C;AAC1D,eAAO;AACL6B,mBAASC,gBAAgB;AACvBA,yBAAaF,MAAb,CAAoB,MAAM;AACxB,oBAAMG,mBAAmBD,aAAaE,aAAb,EAAzB;AACA,oBAAMZ,gBAAgBvG,IAAIiG,UAAJ,CAAe,uBAAf,CAAtB;AACA,oBAAMK,mBAAmBrB,iBACvBC,yBADuB,EAEvBC,UAFuB,EAGvB;AACEC,8BAAc,CAAC8B,gBAAD;AADhB,eAHuB,CAAzB;AAOA,oBAAMT,QAAQJ,UACZnB,yBADY,EAEZC,UAFY,EAGZmB,gBAHY,EAIZC,aAJY,CAAd;AAMA,qBAAOvG,IAAImG,QAAS,IAAGM,KAAM,GAA7B;AACD,aAjBD,EAiBGvB,0BAA0BkC,KAjB7B;AAkBD;AApBI,SAAP;AAsBD,OAvBD;AAwBD;;AAED,QAAIjC,aAAaxD,IAAjB;AACA,QAAI0F,WAAJ;AACA,QAAIhC,OAAOnD,SAASoF,MAAT,CAAgB,CAACC,IAAD,EAAO5B,OAAP,EAAgBD,QAAhB,KAA6B;AACtD,YAAME,aAAarF,WAAWsF,QAAX,CAAoBF,OAApB,EAA6BD,QAA7B,CAAnB;AACA6B,WAAK3B,UAAL,IAAmB;AACjBjE,cAAMuB,YAAYwC,QAAZ;AADW,OAAnB;AAGA,aAAO6B,IAAP;AACD,KANU,EAMR,EANQ,CAAX;AAOA,QAAI/F,UAAJ,EAAgB;AACd,YAAMgG,kBAAkB/F,mBACtBE,IADsB,EAEtB0B,aAFsB,EAGtB5D,KAAKmC,UAHiB,CAAxB;AAKA,YAAM6F,YAAYC,OAAOnE,WAAWH,EAAlB,MAA0B,MAA5C;AACA;AACAiE,oBAAchH,aACZa,iBADY,EAEZ;AACEY,cAAMvB,WAAWoH,mBAAX,CACJlI,KAAKqC,IADD,EAEJrC,KAAKiF,SAAL,CAAe5C,IAFX,CADR;AAKE8F,qBAAc,uBAAsBrH,WAAWsH,YAAX,CAClCpI,KAAKqC,IAD6B,EAElCrC,KAAKiF,SAAL,CAAe5C,IAFmB,CAGlC,cARJ;AASEgG,gBAAQ,CAAC,EAAEC,6BAAF,EAAD,KAAuC;AAC7C,cAAIN,SAAJ,EAAe;AACbM,0CAA8BP,eAA9B;AACD;AACD,iBAAO,sBACL,EADK,EAEL;AACEQ,8BAAkB;AAChBrG,oBAAMb;AADU;AADpB,WAFK,EAOL2G,YACI;AACE,aAACD,eAAD,GAAmB;AACjB7F,oBAAMA,IADW;AAEjBsG,sBAAQC,IAAR,EAAc;AACZ,uBAAOA,KAAKA,IAAZ;AACD;AAJgB;AAMnB;AAPF,WADJ,GAUI,IAjBC,CAAP;AAmBD;AAhCH,OAFY,EAoCZ,sBACE,EADF,EAEE;AACEC,2BAAmB;AADrB,OAFF,EAKEtE,gBALF,CApCY,CAAd;AA4CAsB,mBAAakC,WAAb;AACA,YAAMe,YAAY/H,aAChBc,sBADgB,EAEhB;AACEW,cAAMvB,WAAW8H,iBAAX,CAA6B5I,KAAKqC,IAAlC,EAAwCrC,KAAKiF,SAAL,CAAe5C,IAAvD,CADR;AAEE8F,qBAAc,uBAAsBrH,WAAWsH,YAAX,CAClCpI,KAAKqC,IAD6B,EAElCrC,KAAKiF,SAAL,CAAe5C,IAFmB,CAGlC,cALJ;AAMEgG,gBAAQ,sBACN;AACEE,4BAAkB;AAChBrG,kBAAMb;AADU;AADpB,SADM,EAMNuE,IANM;AANV,OAFgB,EAiBhB;AACEiD,yBAAiB;AADnB,OAjBgB,CAAlB;AAqBAjD,aAAO;AACLE,eAAO;AACL5D,gBAAM,IAAIf,cAAJ,CAAmBwH,SAAnB;AADD;AADF,OAAP;AAKD;;AAED,WAAO;AACLR,mBAAanI,KAAKmI,WAAL,GACTnI,KAAKmI,WADI,GAET1D,eAAezE,KAAKmC,UAApB,GACG,mDACCqC,UAAUnC,IACX,KAHH,GAIE,IAPD;AAQLH,YAAMwD,UARD;AASLE,YAAMA,IATD;AAUL4C,eAAS1G,WACL,CAAC2G,IAAD,EAAOK,KAAP,EAAcC,QAAd,EAAwBC,WAAxB,KAAwC;AACtC,cAAMrB,QAAQlH,wBAAwBuI,WAAxB,CAAd;AACA,cAAM3C,QAAQoC,KAAKd,KAAL,CAAd;AACA,YAAIpD,uBAAJ,EAA6B;AAC3B,cAAIvE,KAAKmC,UAAT,EAAqB;AACnB,mBAAOkE,MAAMoC,IAAN,CACJ7F,GADI,CACAjD,UADA,EAEJiD,GAFI,CAEAqG,KAAKtI,OAAOsI,CAAP,EAAUnF,UAAV,CAFL,CAAP;AAGD,WAJD,MAIO;AACL,mBAAOnD,OAAO0F,KAAP,EAAcvC,UAAd,CAAP;AACD;AACF,SARD,MAQO;AACL,cAAI9D,KAAKmC,UAAL,IAAmB,CAACJ,UAAxB,EAAoC;AAClC,mBAAO,iCAAkBsE,KAAlB,CAAP;AACD,WAFD,MAEO;AACL,mBAAOA,KAAP;AACD;AACF;AACF,OAnBI,GAoBL,OAAOoC,IAAP,EAAa7C,IAAb,EAAmB,EAAEsD,QAAF,EAAnB,EAAiCF,WAAjC,KAAiD;AAC/C,cAAMvD,4BAA4BjF,iBAAiBwI,WAAjB,CAAlC;AACA,cAAMlC,gBAAgBvG,IAAIiG,UAAJ,CAAe,uBAAf,CAAtB;AACA,cAAMK,mBAAmBrB,iBACvBC,yBADuB,EAEvBuD,YAAYlF,UAFW,EAGvB,EAHuB,CAAzB;;AAMA,YAAIqF,WAAJ;AACA,YAAIpH,UAAJ,EAAgB;AACd,gBAAMiF,QAAQJ,UACZnB,yBADY,EAEZuD,YAAYlF,UAFA,EAGZgD,aAHY,EAIZA,aAJY,CAAd;AAMA,gBAAMhD,aAAaF,aAAnB;AACA,gBAAMwF,yBAAyB7I,IAAIiG,UAAJ,CAAe,uBAAf,CAA/B;AACA,gBAAM6C,SAASvF,WAAWH,EAAX,KAAkB,MAAjC;AACA,gBAAM2F,YACJ,CAAC/E,uBAAD,IAA4BP,eAA5B,IAA+C,KADjD;AAEA,cAAI;AACF,kBAAMkF,SAASlC,KAAT,CAAe,4BAAf,CAAN;AACAmC,0BAAc,MAAM,iCAClBD,QADkB,EAElBG,SACI,IADJ,GAEI9I,IAAIiG,UAAJ,CACE1C,WAAWyF,aADb,EAEEzF,WAAWzB,IAFb,CAJc,EAQlB9B,IAAIyG,KAAM,UACRsC,YACI/I,IAAIyG,KAAM,GAAEoC,sBAAuB,IADvC,GAEI7I,IAAIyG,KAAM,GAAEoC,sBAAuB,IAAGA,sBAAuB,OAAMtC,aAAc,EACtF,SAAQD,gBAAiB,IAAGuC,sBAAuB,EAZlC,EAalBtC,aAbkB,EAclBE,KAdkB,EAelBsC,SAfkB,CAApB;AAiBA,kBAAMJ,SAASlC,KAAT,CAAe,oCAAf,CAAN;AACD,WApBD,CAoBE,OAAOwC,CAAP,EAAU;AACV,kBAAMN,SAASlC,KAAT,CACJ,wCADI,CAAN;AAGA,kBAAMwC,CAAN;AACD;AACF,SAtCD,MAsCO;AACL,gBAAMxC,QAAQJ,UACZnB,yBADY,EAEZuD,YAAYlF,UAFA,EAGZ+C,gBAHY,EAIZC,aAJY,CAAd;AAMA,gBAAM,EAAE2C,IAAF,EAAQC,MAAR,KAAmBnJ,IAAIoJ,OAAJ,CAAY3C,KAAZ,CAAzB;AACA,cAAItH,SAASkK,OAAb,EAAsBlK,SAAS+J,IAAT;AACtBN,wBAAc,MAAMD,SAASlC,KAAT,CAAeyC,IAAf,EAAqBC,MAArB,CAApB;AACD;AACD,cAAM,EAAEG,IAAF,KAAWV,WAAjB;AACA,cAAM,CAACW,GAAD,IAAQD,IAAd;AACA,cAAME,SAAS,CAAC,MAAM;AACpB,cAAIxF,uBAAJ,EAA6B;AAC3B,gBAAIvE,KAAKmC,UAAL,IAAmB,CAACJ,UAAxB,EAAoC;AAClC,qBAAO+H,IAAIrB,IAAJ,CACJ7F,GADI,CACAjD,UADA,EAEJiD,GAFI,CAEAqG,KAAKtI,OAAOsI,CAAP,EAAUnF,UAAV,CAFL,CAAP;AAGD,aAJD,MAIO,IAAI9D,KAAKmC,UAAT,EAAqB;AAC1B,qBAAO0H,KAAKjH,GAAL,CAASjD,UAAT,EAAqBiD,GAArB,CAAyBqG,KAAKtI,OAAOsI,CAAP,EAAUnF,UAAV,CAA9B,CAAP;AACD,aAFM,MAEA;AACL,qBAAOnD,OAAOhB,WAAWmK,GAAX,CAAP,EAAwBhG,UAAxB,CAAP;AACD;AACF,WAVD,MAUO;AACL,gBAAI9D,KAAKmC,UAAL,IAAmB,CAACJ,UAAxB,EAAoC;AAClC;AACA,qBAAO,iCAAkB+H,GAAlB,CAAP;AACD,aAHD,MAGO,IAAI9J,KAAKmC,UAAT,EAAqB;AAC1B,qBAAO0H,IAAP;AACD,aAFM,MAEA;AACL,qBAAOC,GAAP;AACD;AACF;AACF,SArBc,GAAf;AAsBA,YAAI/H,UAAJ,EAAgB;AACd,iBAAO;AACLwG,8BAAkB3C,KAAKE,KAAL,CAAWyC,gBADxB;AAELE,kBAAMsB;AAFD,WAAP;AAID,SALD,MAKO;AACL,iBAAOA,MAAP;AACD;AACF;AAzHA,KAAP;AA2HD,GAlVI,EAmVL5F,UAnVK,CAAP;AAqVD","file":"makeProcField.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport camelCase from \"lodash/camelCase\";\nimport pluralize from \"pluralize\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport addStartEndCursor from \"./addStartEndCursor\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { Proc } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\n\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    firstKey = k;\n  }\n  return obj[firstKey];\n};\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: Proc,\n  {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeId,\n    pgGetGqlInputTypeByTypeId,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getAliasFromResolveInfo,\n    gql2pg,\n    pg2gql,\n    newWithHooks,\n    pgInflection: inflection,\n    pgStrictFunctions: strictFunctions,\n    pgTweakFragmentForType,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLInt,\n      GraphQLFloat,\n      GraphQLBoolean,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n  }: {| ...Build |},\n  {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n  }: {\n    fieldWithHooks: FieldWithHooksFunction,\n    computed?: boolean,\n    isMutation?: boolean,\n  }\n) {\n  function getResultFieldName(gqlType, type, returnsSet) {\n    const gqlNamedType = getNamedType(gqlType);\n    let name;\n    if (gqlNamedType === GraphQLInt) {\n      name = \"integer\";\n    } else if (gqlNamedType === GraphQLFloat) {\n      name = \"float\";\n    } else if (gqlNamedType === GraphQLBoolean) {\n      name = \"boolean\";\n    } else if (gqlNamedType === GraphQLString) {\n      name = \"string\";\n    } else {\n      name = camelCase(gqlNamedType.name);\n    }\n    return returnsSet || type.isPgArray ? pluralize(name) : name;\n  }\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds\n    .slice(sliceAmount)\n    .map((_, idx) => proc.argNames[idx + sliceAmount] || \"\");\n  const argTypes = proc.argTypeIds\n    .slice(sliceAmount)\n    .map(typeId => introspectionResultsByKind.typeById[typeId]);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    const Type = pgGetGqlInputTypeByTypeId(type.id) || GraphQLString;\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n\n  const rawReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable && pgGetGqlTypeByTypeId(returnTypeTable.type.id);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(TableType);\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else {\n    const Type = pgGetGqlTypeByTypeId(returnType.id) || GraphQLString;\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(\n        proc.name,\n        proc.namespace.name\n      );\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (ConnectionType) {\n        if (isMutation) {\n          // Cannot return a connection because it would have to run the mutation again\n          type = new GraphQLList(Type);\n          returnFirstValueAsValue = true;\n        } else {\n          type = new GraphQLNonNull(ConnectionType);\n          fieldScope.isPgFieldConnection = true;\n        }\n      } else {\n        returnFirstValueAsValue = true;\n        type = new GraphQLList(Type);\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeMutationCall(\n        parsedResolveInfoFragment,\n        ReturnType,\n        { implicitArgs = [] } = {}\n      ): SQL {\n        const { args: rawArgs = {} } = parsedResolveInfoFragment;\n        const args = isMutation ? rawArgs.input : rawArgs;\n        const sqlArgValues = [];\n        let haveNames = true;\n        for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n          const argName = argNames[argIndex];\n          const gqlArgName = inflection.argument(argName, argIndex);\n          const value = args[gqlArgName];\n          const sqlValue = gql2pg(value, argTypes[argIndex]);\n          if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n            // No need to pass argument to function\n            continue;\n          } else if (argIndex + 1 > requiredArgCount && haveNames) {\n            const sqlArgName = argName ? sql.identifier(argName) : null;\n            if (sqlArgName) {\n              sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n            } else {\n              haveNames = false;\n              sqlArgValues.unshift(sqlValue);\n            }\n          } else {\n            sqlArgValues.unshift(sqlValue);\n          }\n        }\n        return sql.fragment`${sql.identifier(\n          proc.namespace.name,\n          proc.name\n        )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            withPagination: !isMutation && proc.returnsSet,\n            withPaginationAsFields: !isMutation && proc.returnsSet && !computed,\n            asJson: !proc.returnsSet && computed && !returnFirstValueAsValue,\n            addNullCase: !proc.returnsSet && isTableLike,\n          },\n          innerQueryBuilder => {\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}.${functionAlias}`,\n                    returnType\n                  ),\n                  \"value\"\n                );\n              }\n            }\n          }\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlMutationQuery = makeMutationCall(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  {\n                    implicitArgs: [parentTableAlias],\n                  }\n                );\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                return sql.fragment`(${query})`;\n              }, parsedResolveInfoFragment.alias);\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      let args = argNames.reduce((memo, argName, argIndex) => {\n        const gqlArgName = inflection.argument(argName, argIndex);\n        memo[gqlArgName] = {\n          type: argGqlTypes[argIndex],\n        };\n        return memo;\n      }, {});\n      if (isMutation) {\n        const resultFieldName = getResultFieldName(\n          type,\n          rawReturnType,\n          proc.returnsSet\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(\n              proc.name,\n              proc.namespace.name\n            ),\n            description: `The output of our \\`${inflection.functionName(\n              proc.name,\n              proc.namespace.name\n            )}\\` mutation.`,\n            fields: ({ recurseDataGeneratorsForField }) => {\n              if (isNotVoid) {\n                recurseDataGeneratorsForField(resultFieldName);\n              }\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: {\n                        type: type,\n                        resolve(data) {\n                          return data.data;\n                        },\n                      },\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          Object.assign(\n            {},\n            {\n              isMutationPayload: true,\n            },\n            payloadTypeScope\n          )\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc.name, proc.namespace.name),\n            description: `All input for the \\`${inflection.functionName(\n              proc.name,\n              proc.namespace.name\n            )}\\` mutation.`,\n            fields: Object.assign(\n              {\n                clientMutationId: {\n                  type: GraphQLString,\n                },\n              },\n              args\n            ),\n          },\n          {\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n\n      return {\n        description: proc.description\n          ? proc.description\n          : isTableLike && proc.returnsSet\n            ? `Reads and enables pagination through a set of \\`${\n                TableType.name\n              }\\`.`\n            : null,\n        type: ReturnType,\n        args: args,\n        resolve: computed\n          ? (data, _args, _context, resolveInfo) => {\n              const alias = getAliasFromResolveInfo(resolveInfo);\n              const value = data[alias];\n              if (returnFirstValueAsValue) {\n                if (proc.returnsSet) {\n                  return value.data\n                    .map(firstValue)\n                    .map(v => pg2gql(v, returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                if (proc.returnsSet && !isMutation) {\n                  return addStartEndCursor(value);\n                } else {\n                  return value;\n                }\n              }\n            }\n          : async (data, args, { pgClient }, resolveInfo) => {\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              const functionAlias = sql.identifier(Symbol());\n              const sqlMutationQuery = makeMutationCall(\n                parsedResolveInfoFragment,\n                resolveInfo.returnType,\n                {}\n              );\n\n              let queryResult;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias\n                );\n                const returnType = rawReturnType;\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgClass =\n                  !returnFirstValueAsValue || returnTypeTable || false;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResult = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : sql.query`${intermediateIdentifier}.${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlMutationQuery} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                queryResult = await pgClient.query(text, values);\n              }\n              const { rows } = queryResult;\n              const [row] = rows;\n              const result = (() => {\n                if (returnFirstValueAsValue) {\n                  if (proc.returnsSet && !isMutation) {\n                    return row.data\n                      .map(firstValue)\n                      .map(v => pg2gql(v, returnType));\n                  } else if (proc.returnsSet) {\n                    return rows.map(firstValue).map(v => pg2gql(v, returnType));\n                  } else {\n                    return pg2gql(firstValue(row), returnType);\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation) {\n                    // Connection\n                    return addStartEndCursor(row);\n                  } else if (proc.returnsSet) {\n                    return rows;\n                  } else {\n                    return row;\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"]}