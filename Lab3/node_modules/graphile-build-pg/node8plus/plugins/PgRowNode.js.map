{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["base64Decode","str","Buffer","String","toString","debugSql","PgRowByUniqueConstraint","builder","pgInflection","inflection","hook","object","addNodeFetcherForTypeName","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","gql2pg","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","attributes","attribute","filter","attr","classId","id","primaryKeyConstraint","constraint","con","type","primaryKeys","keyAttributeNums","map","num","data","identifiers","pgClient","parsedResolveInfoFragment","ReturnType","resolveData","length","Error","query","undefined","forEach","key","idx","where","fragment","getTableAlias","text","values","compile","enabled","rows","row","fields","nodeIdFieldName","extend","parseResolveInfo","pgGetGqlTypeByTypeId","getNodeType","graphql","GraphQLNonNull","GraphQLID","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","args","resolve","parent","resolveInfo","nodeId","alias","JSON","parse","NodeTypeByAlias","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":"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","file":"PgRowNode.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\n\nconst base64Decode = str => new Buffer(String(str), \"base64\").toString(\"utf8\");\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\nexport default (async function PgRowByUniqueConstraint(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (\n      object,\n      {\n        addNodeFetcherForTypeName,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        gql2pg,\n      },\n      { scope: { isPgRowType, pgIntrospection: table } }\n    ) => {\n      if (!isPgRowType || !table.namespace) {\n        return object;\n      }\n      const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n      const attributes = introspectionResultsByKind.attribute.filter(\n        attr => attr.classId === table.id\n      );\n      const primaryKeyConstraint = introspectionResultsByKind.constraint\n        .filter(con => con.classId === table.id)\n        .filter(con => con.type === \"p\")[0];\n      if (!primaryKeyConstraint) {\n        return object;\n      }\n      const primaryKeys =\n        primaryKeyConstraint &&\n        primaryKeyConstraint.keyAttributeNums.map(\n          num => attributes.filter(attr => attr.num === num)[0]\n        );\n      addNodeFetcherForTypeName(\n        object.name,\n        async (\n          data,\n          identifiers,\n          { pgClient },\n          parsedResolveInfoFragment,\n          ReturnType,\n          resolveData\n        ) => {\n          if (identifiers.length !== primaryKeys.length) {\n            throw new Error(\"Invalid ID\");\n          }\n          const query = queryFromResolveData(\n            sqlFullTableName,\n            undefined,\n            resolveData,\n            {},\n            builder => {\n              primaryKeys.forEach((key, idx) => {\n                builder.where(\n                  sql.fragment`${builder.getTableAlias()}.${sql.identifier(\n                    key.name\n                  )} = ${gql2pg(identifiers[idx], primaryKeys[idx].type)}`\n                );\n              });\n            }\n          );\n          const { text, values } = sql.compile(query);\n          if (debugSql.enabled) debugSql(text);\n          const { rows: [row] } = await pgClient.query(text, values);\n          return row;\n        }\n      );\n      return object;\n    }\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields,\n      {\n        nodeIdFieldName,\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeId,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        gql2pg,\n        getNodeType,\n        graphql: { GraphQLNonNull, GraphQLID },\n      },\n      { scope: { isRootQuery }, fieldWithHooks }\n    ) => {\n      if (!isRootQuery || !nodeIdFieldName) {\n        return fields;\n      }\n      return extend(\n        fields,\n        introspectionResultsByKind.class\n          .filter(table => !!table.namespace)\n          .reduce((memo, table) => {\n            const TableType = pgGetGqlTypeByTypeId(table.type.id);\n            const sqlFullTableName = sql.identifier(\n              table.namespace.name,\n              table.name\n            );\n            if (TableType) {\n              const attributes = introspectionResultsByKind.attribute.filter(\n                attr => attr.classId === table.id\n              );\n              const primaryKeyConstraint = introspectionResultsByKind.constraint\n                .filter(con => con.classId === table.id)\n                .filter(con => con.type === \"p\")[0];\n              if (!primaryKeyConstraint) {\n                return memo;\n              }\n              const primaryKeys =\n                primaryKeyConstraint &&\n                primaryKeyConstraint.keyAttributeNums.map(\n                  num => attributes.filter(attr => attr.num === num)[0]\n                );\n              const fieldName = inflection.tableNode(\n                table.name,\n                table.namespace.name\n              );\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    description: `Reads a single \\`${\n                      TableType.name\n                    }\\` using its globally unique \\`ID\\`.`,\n                    type: TableType,\n                    args: {\n                      [nodeIdFieldName]: {\n                        description: `The globally unique \\`ID\\` to be used in selecting a single \\`${\n                          TableType.name\n                        }\\`.`,\n                        type: new GraphQLNonNull(GraphQLID),\n                      },\n                    },\n                    async resolve(parent, args, { pgClient }, resolveInfo) {\n                      const nodeId = args[nodeIdFieldName];\n                      try {\n                        const [alias, ...identifiers] = JSON.parse(\n                          base64Decode(nodeId)\n                        );\n                        const NodeTypeByAlias = getNodeType(alias);\n                        if (NodeTypeByAlias !== TableType) {\n                          throw new Error(\"Mismatched type\");\n                        }\n                        if (identifiers.length !== primaryKeys.length) {\n                          throw new Error(\"Invalid ID\");\n                        }\n\n                        const parsedResolveInfoFragment = parseResolveInfo(\n                          resolveInfo\n                        );\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          TableType\n                        );\n                        const query = queryFromResolveData(\n                          sqlFullTableName,\n                          undefined,\n                          resolveData,\n                          {},\n                          builder => {\n                            primaryKeys.forEach((key, idx) => {\n                              builder.where(\n                                sql.fragment`${builder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )} = ${gql2pg(\n                                  identifiers[idx],\n                                  primaryKeys[idx].type\n                                )}`\n                              );\n                            });\n                          }\n                        );\n                        const { text, values } = sql.compile(query);\n                        if (debugSql.enabled) debugSql(text);\n                        const { rows: [row] } = await pgClient.query(\n                          text,\n                          values\n                        );\n                        return row;\n                      } catch (e) {\n                        return null;\n                      }\n                    },\n                  };\n                },\n                {\n                  isPgNodeQuery: true,\n                  pgFieldIntrospection: table,\n                }\n              );\n            }\n            return memo;\n          }, {}),\n        `Adding \"row by node ID\" fields to root Query type`\n      );\n    }\n  );\n}: Plugin);\n"]}