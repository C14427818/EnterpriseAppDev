{"version":3,"sources":["../../src/plugins/PgTypesPlugin.js"],"names":["indent","str","replace","stringType","name","description","serialize","value","String","parseValue","parseLiteral","ast","kind","STRING","Error","parseCache","parseInterval","result","get","set","pgRangeParser","parse","parts","split","length","start","inclusive","slice","end","inclusivity","true","false","join","PgTypesPlugin","builder","pgExtendedTypes","pgInflection","inflection","pgLegacyJsonUuid","hook","build","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","addType","pgSql","sql","gqlTypeByTypeIdGenerator","gqlInputTypeByTypeIdGenerator","gqlTypeByTypeId","pgGqlTypeByTypeId","gqlInputTypeByTypeId","pgGqlInputTypeByTypeId","pg2GqlMapper","pg2gql","val","type","id","map","domainBaseType","isPgArray","Array","isArray","namespaceName","v","arrayItemType","gql2pg","null","unmap","fragment","identifier","makeIntervalFields","seconds","minutes","hours","days","months","years","GQLInterval","fields","GQLIntervalInput","pgTypeById","reduce","memo","BigFloat","BitString","rawTypes","tweakToJson","tweakToText","pgTweaksByTypeId","typeId","categoryLookup","B","N","A","enforceGqlTypeByPgType","arrayItemTypeId","pgTweakFragmentForType","tweaker","error","process","env","NODE_ENV","console","SimpleDate","SimpleDatetime","SimpleTime","SimpleJSON","SimpleUUID","JSONType","UUIDType","DateType","DateTimeType","TimeType","Point","x","y","PointInput","oidLookup","oidInputLookup","identity","_","jsonStringify","o","keys","key","push","parseMoney","numerical","lastCommaIndex","lastIndexOf","parseFloat","f","substr","depth","reallyEnforceGqlTypeByPgType","e","message","originalError","gqlType","gqlInputType","enumType","values","enumVariants","enumName","subtype","typeById","rangeSubTypeId","gqlRangeSubType","Range","rangeType","RangeInput","RangeBound","rangeBoundType","RangeBoundInput","inputType","pgRange","parsed","pgParse","indexOf","parseInt","getTypeParser","lower","upper","lowerInclusive","upperInclusive","literal","domainBaseTypeId","baseType","baseInputType","domainType","gen","category","getGqlTypeByTypeId","find","t","Type","getGqlInputTypeByTypeId","registerGqlTypeByTypeId","yieldToExisting","registerGqlInputTypeByTypeId","extend","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId"],"mappings":"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","file":"PgTypesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLList,\n  GraphQLEnumType,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLScalarType,\n  isInputType,\n  getNamedType,\n} from \"graphql\";\nimport { Kind } from \"graphql/language\";\nimport { types as pgTypes } from \"pg\";\n\nimport { GraphQLJSON, GraphQLJson } from \"../GraphQLJSON\";\n\nimport rawParseInterval from \"postgres-interval\";\nimport LRU from \"lru-cache\";\n\nfunction indent(str) {\n  return \"  \" + str.replace(/\\n/g, \"\\n  \");\n}\n\nconst stringType = (name, description) =>\n  new GraphQLScalarType({\n    name,\n    description,\n    serialize: value => String(value),\n    parseValue: value => String(value),\n    parseLiteral: ast => {\n      if (ast.kind !== Kind.STRING) {\n        throw new Error(\"Can only parse string values\");\n      }\n      return ast.value;\n    },\n  });\n/*\nconst {\n  GraphQLDate,\n  GraphQLTime,\n  GraphQLDateTime,\n} = require(\"graphql-iso-date\");\n*/\n\nconst parseCache = LRU(500);\nfunction parseInterval(str) {\n  let result = parseCache.get(str);\n  if (!result) {\n    result = rawParseInterval(str);\n    Object.freeze(result);\n    parseCache.set(str, result);\n  }\n  return result;\n}\n\nconst pgRangeParser = {\n  parse(str) {\n    const parts = str.split(\",\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid daterange\");\n    }\n\n    return {\n      start:\n        parts[0].length > 1\n          ? {\n              inclusive: parts[0][0] === \"[\",\n              value: parts[0].slice(1),\n            }\n          : null,\n      end:\n        parts[1].length > 1\n          ? {\n              inclusive: parts[1][parts[1].length - 1] === \"]\",\n              value: parts[1].slice(0, -1),\n            }\n          : null,\n    };\n  },\n\n  serialize({ start, end }) {\n    const inclusivity = {\n      true: \"[]\",\n      false: \"()\",\n    };\n\n    return [\n      start ? inclusivity[start.inclusive][0] + start.value : \"[\",\n      end ? end.value + inclusivity[end.inclusive][1] : \"]\",\n    ].join(\",\");\n  },\n};\n\nexport default (function PgTypesPlugin(\n  builder,\n  { pgExtendedTypes = true, pgInflection: inflection, pgLegacyJsonUuid = false }\n) {\n  // XXX: most of this should be in an \"init\" hook, not a \"build\" hook\n  builder.hook(\"build\", build => {\n    const {\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      addType,\n      pgSql: sql,\n    } = build;\n\n    const gqlTypeByTypeIdGenerator = {};\n    const gqlInputTypeByTypeIdGenerator = {};\n    const gqlTypeByTypeId = Object.assign({}, build.pgGqlTypeByTypeId);\n    const gqlInputTypeByTypeId = Object.assign(\n      {},\n      build.pgGqlInputTypeByTypeId\n    );\n    const pg2GqlMapper = {};\n    const pg2gql = (val, type) => {\n      if (val == null) {\n        return val;\n      }\n      if (pg2GqlMapper[type.id]) {\n        return pg2GqlMapper[type.id].map(val);\n      } else if (type.domainBaseType) {\n        return pg2gql(val, type.domainBaseType);\n      } else if (type.isPgArray) {\n        if (!Array.isArray(val)) {\n          throw new Error(\n            `Expected array when converting PostgreSQL data into GraphQL; failing type: '${\n              type.namespaceName\n            }.${type.name}'`\n          );\n        }\n        return val.map(v => pg2gql(v, type.arrayItemType));\n      } else {\n        return val;\n      }\n    };\n    const gql2pg = (val, type) => {\n      if (val == null) {\n        return sql.null;\n      }\n      if (pg2GqlMapper[type.id]) {\n        return pg2GqlMapper[type.id].unmap(val);\n      } else if (type.domainBaseType) {\n        return gql2pg(val, type.domainBaseType);\n      } else if (type.isPgArray) {\n        if (!Array.isArray(val)) {\n          throw new Error(\n            `Expected array when converting GraphQL data into PostgreSQL data; failing type: '${\n              type.namespaceName\n            }.${type.name}' (type: ${type === null ? \"null\" : typeof type})`\n          );\n        }\n        return sql.fragment`array[${sql.join(\n          val.map(v => gql2pg(v, type.arrayItemType)),\n          \", \"\n        )}]::${sql.identifier(type.namespaceName)}.${sql.identifier(\n          type.name\n        )}`;\n      } else {\n        return sql.value(val);\n      }\n    };\n    /*\n      type =\n        { kind: 'type',\n          id: '1021',\n          name: '_float4',\n          description: null,\n          namespaceId: '11',\n          namespaceName: 'pg_catalog',\n          type: 'b',\n          category: 'A',\n          domainIsNotNull: false,\n          arrayItemTypeId: '700',\n          classId: null,\n          domainBaseTypeId: null,\n          enumVariants: null,\n          rangeSubTypeId: null }\n      */\n\n    const makeIntervalFields = () => {\n      return {\n        seconds: {\n          description:\n            \"A quantity of seconds. This is the only non-integer field, as all the other fields will dump their overflow into a smaller unit of time. Intervals don’t have a smaller unit than seconds.\",\n          type: GraphQLFloat,\n        },\n        minutes: {\n          description: \"A quantity of minutes.\",\n          type: GraphQLInt,\n        },\n        hours: {\n          description: \"A quantity of hours.\",\n          type: GraphQLInt,\n        },\n        days: {\n          description: \"A quantity of days.\",\n          type: GraphQLInt,\n        },\n        months: {\n          description: \"A quantity of months.\",\n          type: GraphQLInt,\n        },\n        years: {\n          description: \"A quantity of years.\",\n          type: GraphQLInt,\n        },\n      };\n    };\n    const GQLInterval = new GraphQLObjectType({\n      name: \"Interval\",\n      description:\n        \"An interval of time that has passed where the smallest distinct unit is a second.\",\n      fields: makeIntervalFields(),\n    });\n    addType(GQLInterval);\n\n    const GQLIntervalInput = new GraphQLInputObjectType({\n      name: \"IntervalInput\",\n      description:\n        \"An interval of time that has passed where the smallest distinct unit is a second.\",\n      fields: makeIntervalFields(),\n    });\n    addType(GQLIntervalInput);\n\n    const pgTypeById = introspectionResultsByKind.type.reduce((memo, type) => {\n      memo[type.id] = type;\n      return memo;\n    }, {});\n\n    const BigFloat = stringType(\n      \"BigFloat\",\n      \"A floating point number that requires more precision than IEEE 754 binary 64\"\n    );\n    const BitString = stringType(\n      \"BitString\",\n      \"A string representing a series of binary bits\"\n    );\n    addType(BigFloat);\n    addType(BitString);\n\n    const rawTypes = [\n      1186, // interval\n      1082, // date\n      1114, // timestamp\n      1184, // timestamptz\n      1083, // time\n      1266, // timetz\n    ];\n\n    const tweakToJson = fragment => fragment; // Since everything is to_json'd now, just pass through\n    const tweakToText = fragment => sql.fragment`(${fragment})::text`;\n    const pgTweaksByTypeId = Object.assign(\n      // ::text rawTypes\n      rawTypes.reduce((memo, typeId) => {\n        memo[typeId] = tweakToText;\n        return memo;\n      }, {}),\n      {\n        // cast numbers above our ken to strings to avoid loss of precision\n        \"20\": tweakToText,\n        \"1700\": tweakToText,\n        // to_json all dates to make them ISO (overrides rawTypes above)\n        \"1082\": tweakToJson,\n        \"1114\": tweakToJson,\n        \"1184\": tweakToJson,\n        \"1083\": tweakToJson,\n        \"1266\": tweakToJson,\n      }\n    );\n\n    const categoryLookup = {\n      B: () => GraphQLBoolean,\n\n      // Numbers may be too large for GraphQL/JS to handle, so stringify by\n      // default.\n      N: type => {\n        pgTweaksByTypeId[type.id] = tweakToText;\n        return BigFloat;\n      },\n\n      A: type =>\n        new GraphQLList(\n          enforceGqlTypeByPgType(pgTypeById[type.arrayItemTypeId])\n        ),\n    };\n\n    const pgTweakFragmentForType = (fragment, type) => {\n      const tweaker = pgTweaksByTypeId[type.id];\n      if (tweaker) {\n        return tweaker(fragment);\n      } else if (type.domainBaseType) {\n        return pgTweakFragmentForType(fragment, type.domainBaseType);\n      } else if (type.isPgArray) {\n        const error = new Error(\n          \"Internal graphile-build-pg error: should not attempt to tweak an array, please process array before tweaking (type: `${type.namespaceName}.${type.name}`)\"\n        );\n        if (process.env.NODE_ENV === \"test\") {\n          throw error;\n        }\n        // eslint-disable-next-line no-console\n        console.error(error);\n        return fragment;\n      } else {\n        return fragment;\n      }\n    };\n    /*\n        Determined by running:\n\n          select oid, typname, typarray, typcategory, typtype from pg_catalog.pg_type where typtype = 'b' order by oid;\n\n        We only need to add oidLookups for types that don't have the correct fallback\n      */\n    const SimpleDate = stringType(\"Date\", \"The day, does not include a time.\");\n    const SimpleDatetime = stringType(\n      \"Datetime\",\n      \"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\"\n    );\n    const SimpleTime = stringType(\n      \"Time\",\n      \"The exact time of day, does not include the date. May or may not have a timezone offset.\"\n    );\n    const SimpleJSON = stringType(\n      pgLegacyJsonUuid ? \"Json\" : \"JSON\",\n      \"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).\"\n    );\n    const SimpleUUID = stringType(\n      pgLegacyJsonUuid ? \"Uuid\" : \"UUID\",\n      \"A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).\"\n    );\n\n    // pgExtendedTypes might change what types we use for things\n    const JSONType = pgExtendedTypes\n      ? pgLegacyJsonUuid ? GraphQLJson : GraphQLJSON\n      : SimpleJSON;\n    const UUIDType = SimpleUUID; // GraphQLUUID\n    const DateType = SimpleDate; // GraphQLDate\n    const DateTimeType = SimpleDatetime; // GraphQLDateTime\n    const TimeType = SimpleTime; // GraphQLTime\n\n    // 'point' in PostgreSQL is a 16-byte type that's comprised of two 8-byte floats.\n    const Point = new GraphQLObjectType({\n      name: \"Point\",\n      fields: {\n        x: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n        y: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n      },\n    });\n    const PointInput = new GraphQLInputObjectType({\n      name: \"PointInput\",\n      fields: {\n        x: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n        y: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n      },\n    });\n\n    // Other plugins might want to use JSON\n    addType(JSONType);\n    addType(UUIDType);\n    addType(DateType);\n    addType(DateTimeType);\n    addType(TimeType);\n\n    const oidLookup = {\n      \"20\": stringType(\n        \"BigInt\",\n        \"A signed eight-byte integer. The upper big integer values are greater then the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers.\"\n      ), // bitint - even though this is int8, it's too big for JS int, so cast to string.\n      \"21\": GraphQLInt, // int2\n      \"23\": GraphQLInt, // int4\n      \"700\": GraphQLFloat, // float4\n      \"701\": GraphQLFloat, // float8\n      \"1700\": BigFloat, // numeric\n      \"790\": GraphQLFloat, // money\n\n      \"1186\": GQLInterval, // interval\n      \"1082\": DateType, // date\n      \"1114\": DateTimeType, // timestamp\n      \"1184\": DateTimeType, // timestamptz\n      \"1083\": TimeType, // time\n      \"1266\": TimeType, // timetz\n\n      \"114\": JSONType, // json\n      \"3802\": JSONType, // jsonb\n      \"2950\": UUIDType, // uuid\n\n      \"1560\": BitString, // bit\n      \"1562\": BitString, // varbit\n\n      \"18\": GraphQLString, // char\n      \"25\": GraphQLString, // text\n      \"1043\": GraphQLString, // varchar\n\n      \"600\": Point, // point\n    };\n    const oidInputLookup = {\n      \"1186\": GQLIntervalInput, // interval\n      \"600\": PointInput, // point\n    };\n    const identity = _ => _;\n    const jsonStringify = o => JSON.stringify(o);\n    if (pgExtendedTypes) {\n      pg2GqlMapper[114] = {\n        map: identity,\n        unmap: o => sql.value(jsonStringify(o)),\n      };\n    } else {\n      pg2GqlMapper[114] = {\n        map: jsonStringify,\n        unmap: str => sql.value(str),\n      };\n    }\n    pg2GqlMapper[3802] = pg2GqlMapper[114]; // jsonb\n\n    // interval\n    pg2GqlMapper[1186] = {\n      map: str => parseInterval(str),\n      unmap: o => {\n        const keys = [\"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\"];\n        const parts = [];\n        for (const key of keys) {\n          if (o[key]) {\n            parts.push(`${o[key]} ${key}`);\n          }\n        }\n        return sql.value(parts.join(\" \") || \"0 seconds\");\n      },\n    };\n\n    const parseMoney = str => {\n      const numerical = str.replace(/[^0-9.,]/g, \"\");\n      const lastCommaIndex = numerical.lastIndexOf(\",\");\n      if (lastCommaIndex >= 0 && lastCommaIndex === numerical.length - 3) {\n        // Assume string is of the form '123.456,78'\n        return parseFloat(numerical.replace(/\\./g, \"\").replace(\",\", \".\"));\n      } else {\n        // Assume string is of the form '123,456.78'\n        return parseFloat(numerical.replace(/,/g, \"\"));\n      }\n    };\n    pg2GqlMapper[790] = {\n      map: parseMoney,\n      unmap: val => sql.fragment`(${sql.value(val)})::money`,\n    };\n\n    // point\n    pg2GqlMapper[600] = {\n      map: f => {\n        if (f[0] === \"(\" && f[f.length - 1] === \")\") {\n          const [x, y] = f\n            .substr(1, f.length - 2)\n            .split(\",\")\n            .map(f => parseFloat(f));\n          return { x, y };\n        }\n      },\n      unmap: o => sql.fragment`point(${sql.value(o.x)}, ${sql.value(o.y)})`,\n    };\n\n    // TODO: add more support for geometric types\n\n    let depth = 0;\n    const enforceGqlTypeByPgType = type => {\n      depth++;\n      if (depth > 50) {\n        throw new Error(\"Type enforcement went too deep - infinite loop?\");\n      }\n      try {\n        return reallyEnforceGqlTypeByPgType(type);\n      } catch (e) {\n        const error = new Error(\n          `Error occurred when processing database type '${\n            type.namespaceName\n          }.${type.name}' (type=${type.type}):\\n${indent(e.message)}`\n        );\n        // $FlowFixMe\n        error.originalError = e;\n        throw error;\n      } finally {\n        depth--;\n      }\n    };\n    const reallyEnforceGqlTypeByPgType = type => {\n      if (!type.id) {\n        throw new Error(\n          `Invalid argument to enforceGqlTypeByPgType - expected a full type, received '${type}'`\n        );\n      }\n      // Explicit overrides\n      if (!gqlTypeByTypeId[type.id]) {\n        const gqlType = oidLookup[type.id];\n        if (gqlType) {\n          gqlTypeByTypeId[type.id] = gqlType;\n        }\n      }\n      if (!gqlInputTypeByTypeId[type.id]) {\n        const gqlInputType = oidInputLookup[type.id];\n        if (gqlInputType) {\n          gqlInputTypeByTypeId[type.id] = gqlInputType;\n        }\n      }\n      // Enums\n      if (!gqlTypeByTypeId[type.id] && type.type === \"e\") {\n        gqlTypeByTypeId[type.id] = new GraphQLEnumType({\n          name: inflection.enumType(type.name),\n          description: type.description,\n          values: type.enumVariants.reduce((memo, value) => {\n            memo[inflection.enumName(value)] = {\n              value: value,\n            };\n            return memo;\n          }, {}),\n        });\n      }\n      // Ranges\n      if (!gqlTypeByTypeId[type.id] && type.type === \"r\") {\n        const subtype =\n          introspectionResultsByKind.typeById[type.rangeSubTypeId];\n        const gqlRangeSubType = enforceGqlTypeByPgType(subtype);\n        if (!gqlRangeSubType) {\n          throw new Error(\"Range of unsupported\");\n        }\n        let Range = getTypeByName(inflection.rangeType(gqlRangeSubType.name));\n        let RangeInput;\n        if (!Range) {\n          const RangeBound = new GraphQLObjectType({\n            name: inflection.rangeBoundType(gqlRangeSubType.name),\n            description:\n              \"The value at one end of a range. A range can either include this value, or not.\",\n            fields: {\n              value: {\n                description: \"The value at one end of our range.\",\n                type: new GraphQLNonNull(gqlRangeSubType),\n              },\n              inclusive: {\n                description:\n                  \"Whether or not the value of this bound is included in the range.\",\n                type: new GraphQLNonNull(GraphQLBoolean),\n              },\n            },\n          });\n          const RangeBoundInput = new GraphQLInputObjectType({\n            name: inflection.inputType(RangeBound.name),\n            description:\n              \"The value at one end of a range. A range can either include this value, or not.\",\n            fields: {\n              value: {\n                description: \"The value at one end of our range.\",\n                type: new GraphQLNonNull(gqlRangeSubType),\n              },\n              inclusive: {\n                description:\n                  \"Whether or not the value of this bound is included in the range.\",\n                type: new GraphQLNonNull(GraphQLBoolean),\n              },\n            },\n          });\n          Range = new GraphQLObjectType({\n            name: inflection.rangeType(gqlRangeSubType.name),\n            description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n            fields: {\n              start: {\n                description: \"The starting bound of our range.\",\n                type: RangeBound,\n              },\n              end: {\n                description: \"The ending bound of our range.\",\n                type: RangeBound,\n              },\n            },\n          });\n          RangeInput = new GraphQLInputObjectType({\n            name: inflection.inputType(Range.name),\n            description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n            fields: {\n              start: {\n                description: \"The starting bound of our range.\",\n                type: RangeBoundInput,\n              },\n              end: {\n                description: \"The ending bound of our range.\",\n                type: RangeBoundInput,\n              },\n            },\n          });\n          addType(Range);\n          addType(RangeInput);\n        } else {\n          RangeInput = getTypeByName(inflection.inputType(Range.name));\n        }\n        gqlTypeByTypeId[type.id] = Range;\n        gqlInputTypeByTypeId[type.id] = RangeInput;\n        pg2GqlMapper[type.id] = {\n          map: pgRange => {\n            const parsed = pgRangeParser.parse(pgRange);\n            // Since the value we will get from `parsed.(start|end).value` is a\n            // string but our code will expect it to be the value after `pg`\n            // parsed it, we pass through to `pg-types` for parsing.\n            const pgParse =\n              rawTypes.indexOf(parseInt(subtype.id, 10)) >= 0\n                ? identity\n                : pgTypes.getTypeParser(subtype.id);\n            const { start, end } = parsed;\n            return {\n              start: start\n                ? {\n                    value: pg2gql(pgParse(start.value), subtype),\n                    inclusive: start.inclusive,\n                  }\n                : null,\n              end: end\n                ? {\n                    value: pg2gql(pgParse(end.value), subtype),\n                    inclusive: end.inclusive,\n                  }\n                : null,\n            };\n          },\n          unmap: ({ start, end }) => {\n            // Ref: https://www.postgresql.org/docs/9.6/static/rangetypes.html#RANGETYPES-CONSTRUCT\n            const lower = (start && gql2pg(start.value, subtype)) || sql.null;\n            const upper = (end && gql2pg(end.value, subtype)) || sql.null;\n            const lowerInclusive = start && !start.inclusive ? \"(\" : \"[\";\n            const upperInclusive = end && !end.inclusive ? \")\" : \"]\";\n            return sql.fragment`${sql.identifier(\n              type.namespaceName,\n              type.name\n            )}(${lower}, ${upper}, ${sql.literal(\n              lowerInclusive + upperInclusive\n            )})`;\n          },\n        };\n      }\n\n      // Domains\n      if (\n        !gqlTypeByTypeId[type.id] &&\n        type.type === \"d\" &&\n        type.domainBaseTypeId\n      ) {\n        const baseType = enforceGqlTypeByPgType(type.domainBaseType);\n        const baseInputType = gqlInputTypeByTypeId[type.domainBaseTypeId];\n        // Hack stolen from: https://github.com/graphile/postgraphile/blob/ade728ed8f8e3ecdc5fdad7d770c67aa573578eb/src/graphql/schema/type/aliasGqlType.ts#L16\n        gqlTypeByTypeId[type.id] = Object.assign(Object.create(baseType), {\n          name: inflection.domainType(type.name),\n          description: type.description,\n        });\n        if (baseInputType && baseInputType !== baseType) {\n          gqlInputTypeByTypeId[type.id] = Object.assign(\n            Object.create(baseInputType),\n            {\n              name: inflection.inputType(gqlTypeByTypeId[type.id]),\n              description: type.description,\n            }\n          );\n        }\n      }\n\n      // Fall back to categories\n      if (!gqlTypeByTypeId[type.id]) {\n        const gen = categoryLookup[type.category];\n        if (gen) {\n          gqlTypeByTypeId[type.id] = gen(type);\n        }\n      }\n\n      // Nothing else worked; pass through as string!\n      if (!gqlTypeByTypeId[type.id]) {\n        // XXX: consider using stringType(upperFirst(camelCase(`fallback_${type.name}`)), type.description)?\n        gqlTypeByTypeId[type.id] = GraphQLString;\n      }\n      // Now for input types, fall back to output types if possible\n      if (!gqlInputTypeByTypeId[type.id]) {\n        if (isInputType(gqlTypeByTypeId[type.id])) {\n          gqlInputTypeByTypeId[type.id] = gqlTypeByTypeId[type.id];\n        }\n      }\n      addType(getNamedType(gqlTypeByTypeId[type.id]));\n      return gqlTypeByTypeId[type.id];\n    };\n\n    function getGqlTypeByTypeId(typeId) {\n      if (!gqlInputTypeByTypeIdGenerator[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        return enforceGqlTypeByPgType(type);\n      }\n      if (!gqlTypeByTypeId[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        if (!type) {\n          throw new Error(\n            `Type '${typeId}' not present in introspection results`\n          );\n        }\n        const gen = gqlTypeByTypeIdGenerator[type.id];\n        if (gen) {\n          const set = Type => {\n            gqlTypeByTypeId[type.id] = Type;\n          };\n          const result = gen(set);\n          if (result) {\n            if (\n              gqlTypeByTypeId[type.id] &&\n              gqlTypeByTypeId[type.id] !== result\n            ) {\n              throw new Error(\n                `Callback and return types differ when defining type for '${\n                  type.id\n                }'`\n              );\n            }\n            gqlTypeByTypeId[type.id] = result;\n          }\n        }\n      }\n      return gqlTypeByTypeId[typeId];\n    }\n    function getGqlInputTypeByTypeId(typeId) {\n      if (!gqlInputTypeByTypeIdGenerator[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        enforceGqlTypeByPgType(type);\n        return gqlInputTypeByTypeId[typeId];\n      }\n      if (!gqlInputTypeByTypeId[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        getGqlTypeByTypeId(typeId);\n        if (!type) {\n          throw new Error(\n            `Type '${typeId}' not present in introspection results`\n          );\n        }\n        const gen = gqlInputTypeByTypeIdGenerator[type.id];\n        if (gen) {\n          const set = Type => {\n            gqlInputTypeByTypeId[type.id] = Type;\n          };\n          const result = gen(set);\n          if (result) {\n            if (\n              gqlInputTypeByTypeId[type.id] &&\n              gqlInputTypeByTypeId[type.id] !== result\n            ) {\n              throw new Error(\n                `Callback and return types differ when defining type for '${\n                  type.id\n                }'`\n              );\n            }\n            gqlInputTypeByTypeId[type.id] = result;\n          }\n        }\n      }\n      return gqlInputTypeByTypeId[typeId];\n    }\n\n    function registerGqlTypeByTypeId(typeId, gen, yieldToExisting = false) {\n      if (gqlTypeByTypeIdGenerator[typeId]) {\n        if (yieldToExisting) {\n          return;\n        }\n        throw new Error(\n          `There's already a type generator registered for '${typeId}'`\n        );\n      }\n      gqlTypeByTypeIdGenerator[typeId] = gen;\n    }\n    function registerGqlInputTypeByTypeId(\n      typeId,\n      gen,\n      yieldToExisting = false\n    ) {\n      if (gqlInputTypeByTypeIdGenerator[typeId]) {\n        if (yieldToExisting) {\n          return;\n        }\n        throw new Error(\n          `There's already an input type generator registered for '${typeId}'`\n        );\n      }\n      gqlInputTypeByTypeIdGenerator[typeId] = gen;\n    }\n\n    return build.extend(build, {\n      pgRegisterGqlTypeByTypeId: registerGqlTypeByTypeId,\n      pgRegisterGqlInputTypeByTypeId: registerGqlInputTypeByTypeId,\n      pgGetGqlTypeByTypeId: getGqlTypeByTypeId,\n      pgGetGqlInputTypeByTypeId: getGqlInputTypeByTypeId,\n      pg2GqlMapper,\n      pg2gql,\n      gql2pg,\n      pgTweakFragmentForType,\n      pgTweaksByTypeId,\n    });\n  });\n}: Plugin);\n"]}