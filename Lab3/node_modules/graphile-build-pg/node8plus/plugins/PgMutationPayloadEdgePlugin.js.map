{"version":3,"sources":["../../src/plugins/PgMutationPayloadEdgePlugin.js"],"names":["PgMutationPayloadEdgePlugin","builder","pgInflection","inflection","hook","fields","extend","getTypeByName","pgGetGqlTypeByTypeId","pgSql","sql","graphql","GraphQLList","GraphQLNonNull","pgIntrospectionResultsByKind","introspectionResultsByKind","scope","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","recurseDataGeneratorsForField","Self","table","kind","namespace","isSelectable","TableType","type","id","tableTypeName","name","TableOrderByType","orderByType","TableEdgeType","edge","attributes","attribute","filter","attr","classId","primaryKeyConstraint","constraint","con","primaryKeys","keyAttributeNums","map","num","fieldName","edgeField","addArgDataGenerator","connectionOrderBy","orderBy","rawOrderBy","Array","isArray","pgQuery","queryBuilder","aliases","expressions","unique","forEach","item","alias","specs","itemIsUnique","orders","col","_ascending","expr","fragment","getTableAlias","identifier","push","key","length","select","join","a","literal","defaultValueEnum","getValues","find","v","description","args","defaultValue","value","resolve","data","order","some","__identifiers","__cursor","isPgMutationPayloadEdgeField","pgFieldIntrospection"],"mappings":"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","file":"PgMutationPayloadEdgePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport isString from \"lodash/isString\";\n\nexport default (function PgMutationPayloadEdgePlugin(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields,\n      {\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeId,\n        pgSql: sql,\n        graphql: { GraphQLList, GraphQLNonNull },\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n      },\n      {\n        scope: { isMutationPayload, pgIntrospection, pgIntrospectionTable },\n        fieldWithHooks,\n        recurseDataGeneratorsForField,\n        Self,\n      }\n    ) => {\n      const table = pgIntrospectionTable || pgIntrospection;\n      if (\n        !isMutationPayload ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        !table.isSelectable\n      ) {\n        return fields;\n      }\n      const TableType = pgGetGqlTypeByTypeId(table.type.id);\n      const tableTypeName = TableType.name;\n      const TableOrderByType = getTypeByName(\n        inflection.orderByType(tableTypeName)\n      );\n      const TableEdgeType = getTypeByName(inflection.edge(tableTypeName));\n      if (!TableEdgeType) {\n        return fields;\n      }\n\n      const attributes = introspectionResultsByKind.attribute.filter(\n        attr => attr.classId === table.id\n      );\n      const primaryKeyConstraint = introspectionResultsByKind.constraint\n        .filter(con => con.classId === table.id)\n        .filter(con => con.type === \"p\")[0];\n      const primaryKeys =\n        primaryKeyConstraint &&\n        primaryKeyConstraint.keyAttributeNums.map(\n          num => attributes.filter(attr => attr.num === num)[0]\n        );\n\n      const fieldName = inflection.edgeField(table.name, table.namespace.name);\n      recurseDataGeneratorsForField(fieldName);\n      return extend(\n        fields,\n        {\n          [fieldName]: fieldWithHooks(\n            fieldName,\n            ({ addArgDataGenerator }) => {\n              addArgDataGenerator(function connectionOrderBy({\n                orderBy: rawOrderBy,\n              }) {\n                const orderBy = rawOrderBy\n                  ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy]\n                  : null;\n                return {\n                  pgQuery: queryBuilder => {\n                    if (orderBy != null) {\n                      const aliases = [];\n                      const expressions = [];\n                      let unique = false;\n                      orderBy.forEach(item => {\n                        const { alias, specs, unique: itemIsUnique } = item;\n                        unique = unique || itemIsUnique;\n                        const orders = Array.isArray(specs[0])\n                          ? specs\n                          : [specs];\n                        orders.forEach(([col, _ascending]) => {\n                          if (!col) {\n                            return;\n                          }\n                          const expr = isString(col)\n                            ? sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                col\n                              )}`\n                            : col;\n                          expressions.push(expr);\n                        });\n                        if (alias == null) return;\n                        aliases.push(alias);\n                      });\n                      if (!unique && primaryKeys) {\n                        // Add PKs\n                        primaryKeys.forEach(key => {\n                          expressions.push(\n                            sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                              key.name\n                            )}`\n                          );\n                        });\n                      }\n                      if (aliases.length) {\n                        queryBuilder.select(\n                          sql.fragment`json_build_array(${sql.join(\n                            aliases.map(\n                              a => sql.fragment`${sql.literal(a)}::text`\n                            ),\n                            \", \"\n                          )}, json_build_array(${sql.join(\n                            expressions,\n                            \", \"\n                          )}))`,\n                          \"__order_\" + aliases.join(\"__\")\n                        );\n                      }\n                    }\n                  },\n                };\n              });\n\n              const defaultValueEnum =\n                TableOrderByType.getValues().find(\n                  v => v.name === \"PRIMARY_KEY_ASC\"\n                ) || TableOrderByType.getValues()[0];\n              return {\n                description: `An edge for our \\`${tableTypeName}\\`. May be used by Relay 1.`,\n                type: TableEdgeType,\n                args: {\n                  orderBy: {\n                    description: `The method to use when ordering \\`${tableTypeName}\\`.`,\n                    type: new GraphQLList(new GraphQLNonNull(TableOrderByType)),\n                    defaultValue: defaultValueEnum && defaultValueEnum.value,\n                  },\n                },\n                resolve(data, { orderBy: rawOrderBy }) {\n                  const orderBy = rawOrderBy\n                    ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy]\n                    : null;\n                  const order =\n                    orderBy && orderBy.some(item => item.alias)\n                      ? orderBy.filter(item => item.alias)\n                      : null;\n\n                  if (!order) {\n                    if (data.data.__identifiers) {\n                      return Object.assign({}, data.data, {\n                        __cursor: [\"primary_key_asc\", data.data.__identifiers],\n                      });\n                    } else {\n                      return data.data;\n                    }\n                  }\n                  return Object.assign({}, data.data, {\n                    __cursor:\n                      data.data[\n                        `__order_${order.map(item => item.alias).join(\"__\")}`\n                      ],\n                  });\n                },\n              };\n            },\n            {\n              isPgMutationPayloadEdgeField: true,\n              pgFieldIntrospection: table,\n            }\n          ),\n        },\n        `Adding edge field to mutation payload '${Self.name}'`\n      );\n    }\n  );\n}: Plugin);\n"]}