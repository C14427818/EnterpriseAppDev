{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["debugSql","PgRowByUniqueConstraint","builder","pgInflection","inflection","hook","fields","extend","parseResolveInfo","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","scope","isRootQuery","fieldWithHooks","class","filter","table","namespace","reduce","memo","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraint","con","classId","attributes","attribute","attr","sort","a","b","num","forEach","keys","keyAttributeNums","map","every","_","Error","simpleKeys","k","column","schema","fieldName","rowByUniqueKeys","getDataFromParsedResolveInfoFragment","args","key","InputType","typeId","resolve","parent","pgClient","resolveInfo","parsedResolveInfoFragment","resolveData","query","undefined","where","fragment","getTableAlias","text","values","compile","enabled","rows","row","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":";;;;;;AAEA;;;;AACA;;;;;;AACA,MAAMA,WAAW,qBAAa,uBAAb,CAAjB;;kBAEgB,eAAeC,uBAAf,CACdC,OADc,EAEd,EAAEC,cAAcC,UAAhB,EAFc,EAGd;AACAF,UAAQG,IAAR,CACE,0BADF,EAEE,CACEC,MADF,EAEE;AACEC,UADF;AAEEC,oBAFF;AAGEC,wBAHF;AAIEC,6BAJF;AAKEC,UALF;AAMEC,kCAA8BC,0BANhC;AAOEC,WAAOC,GAPT;AAQEC,aAAS,EAAEC,cAAF;AARX,GAFF,EAYE,EAAEC,OAAO,EAAEC,WAAF,EAAT,EAA0BC,cAA1B,EAZF,KAaK;AACH,QAAI,CAACD,WAAL,EAAkB;AAChB,aAAOb,MAAP;AACD;AACD,WAAOC,OACLD,MADK,EAELO,2BAA2BQ,KAA3B,CACGC,MADH,CACUC,SAAS,CAAC,CAACA,MAAMC,SAD3B,EAEGC,MAFH,CAEU,CAACC,IAAD,EAAOH,KAAP,KAAiB;AACvB,YAAMI,YAAYlB,qBAAqBc,MAAMK,IAAN,CAAWC,EAAhC,CAAlB;AACA,YAAMC,mBAAmBf,IAAIgB,UAAJ,CACvBR,MAAMC,SAAN,CAAgBQ,IADO,EAEvBT,MAAMS,IAFiB,CAAzB;AAIA,UAAIL,SAAJ,EAAe;AACb,cAAMM,oBAAoBpB,2BAA2BqB,UAA3B,CACvBZ,MADuB,CAChBa,OAAOA,IAAIC,OAAJ,KAAgBb,MAAMM,EADb,EAEvBP,MAFuB,CAEhBa,OAAOA,IAAIP,IAAJ,KAAa,GAAb,IAAoBO,IAAIP,IAAJ,KAAa,GAFxB,CAA1B;AAGA,cAAMS,aAAaxB,2BAA2ByB,SAA3B,CAChBhB,MADgB,CACTiB,QAAQA,KAAKH,OAAL,KAAiBb,MAAMM,EADtB,EAEhBW,IAFgB,CAEX,CAACC,CAAD,EAAIC,CAAJ,KAAUD,EAAEE,GAAF,GAAQD,EAAEC,GAFT,CAAnB;AAGAV,0BAAkBW,OAAlB,CAA0BV,cAAc;AACtC,gBAAMW,OAAOX,WAAWY,gBAAX,CAA4BC,GAA5B,CACXJ,OAAON,WAAWf,MAAX,CAAkBiB,QAAQA,KAAKI,GAAL,KAAaA,GAAvC,EAA4C,CAA5C,CADI,CAAb;AAGA,cAAI,CAACE,KAAKG,KAAL,CAAWC,KAAKA,CAAhB,CAAL,EAAyB;AACvB,kBAAM,IAAIC,KAAJ,CACJ,iDADI,CAAN;AAGD;AACD,gBAAMC,aAAaN,KAAKE,GAAL,CAASK,MAAM;AAChCC,oBAAQD,EAAEpB,IADsB;AAEhCT,mBAAO6B,EAAE/B,KAAF,CAAQW,IAFiB;AAGhCsB,oBAAQF,EAAE/B,KAAF,CAAQG,SAAR,CAAkBQ;AAHM,WAAN,CAAT,CAAnB;AAKA,gBAAMuB,YAAYnD,WAAWoD,eAAX,CAChBL,UADgB,EAEhB5B,MAAMS,IAFU,EAGhBT,MAAMC,SAAN,CAAgBQ,IAHA,CAAlB;AAKAN,eAAK6B,SAAL,IAAkBnC,eAChBmC,SADgB,EAEhB,CAAC,EAAEE,oCAAF,EAAD,KAA8C;AAC5C,mBAAO;AACL7B,oBAAMD,SADD;AAEL+B,oBAAMb,KAAKpB,MAAL,CAAY,CAACC,IAAD,EAAOiC,GAAP,KAAe;AAC/B,sBAAMC,YAAYlD,0BAA0BiD,IAAIE,MAA9B,CAAlB;AACA,oBAAI,CAACD,SAAL,EAAgB;AACd,wBAAM,IAAIV,KAAJ,CACH,sCACCS,IAAI3B,IACL,cAAaL,UAAUK,IAAK,GAHzB,CAAN;AAKD;AACDN,qBACEtB,WAAWiD,MAAX,CACEM,IAAI3B,IADN,EAEE2B,IAAItC,KAAJ,CAAUW,IAFZ,EAGE2B,IAAItC,KAAJ,CAAUG,SAAV,CAAoBQ,IAHtB,CADF,IAMI;AACFJ,wBAAM,IAAIX,cAAJ,CAAmB2C,SAAnB;AADJ,iBANJ;AASA,uBAAOlC,IAAP;AACD,eAnBK,EAmBH,EAnBG,CAFD;AAsBL,oBAAMoC,OAAN,CAAcC,MAAd,EAAsBL,IAAtB,EAA4B,EAAEM,QAAF,EAA5B,EAA0CC,WAA1C,EAAuD;AACrD,sBAAMC,4BAA4B1D,iBAChCyD,WADgC,CAAlC;AAGA,sBAAME,cAAcV,qCAClBS,yBADkB,EAElBvC,SAFkB,CAApB;AAIA,sBAAMyC,QAAQ,oCACZtC,gBADY,EAEZuC,SAFY,EAGZF,WAHY,EAIZ,EAJY,EAKZjE,WAAW;AACT2C,uBAAKD,OAAL,CAAae,OAAO;AAClBzD,4BAAQoE,KAAR,CACEvD,IAAIwD,QAAS,GAAErE,QAAQsE,aAAR,EAAwB,IAAGzD,IAAIgB,UAAJ,CACxC4B,IAAI3B,IADoC,CAExC,MAAKrB,OACL+C,KACEtD,WAAWiD,MAAX,CACEM,IAAI3B,IADN,EAEE2B,IAAItC,KAAJ,CAAUW,IAFZ,EAGE2B,IAAItC,KAAJ,CAAUG,SAAV,CAAoBQ,IAHtB,CADF,CADK,EAQL2B,IAAI/B,IARC,CASL,EAZJ;AAcD,mBAfD;AAgBD,iBAtBW,CAAd;AAwBA,sBAAM,EAAE6C,IAAF,EAAQC,MAAR,KAAmB3D,IAAI4D,OAAJ,CAAYP,KAAZ,CAAzB;AACA,oBAAIpE,SAAS4E,OAAb,EAAsB5E,SAASyE,IAAT;AACtB,sBAAM,EAAEI,MAAM,CAACC,GAAD,CAAR,KAAkB,MAAMd,SAASI,KAAT,CAC5BK,IAD4B,EAE5BC,MAF4B,CAA9B;AAIA,uBAAOI,GAAP;AACD;AA7DI,aAAP;AA+DD,WAlEe,EAmEhB;AACEC,4CAAgC,IADlC;AAEEC,kCAAsB9C;AAFxB,WAnEgB,CAAlB;AAwED,SA3FD;AA4FD;AACD,aAAOR,IAAP;AACD,KA7GH,EA6GK,EA7GL,CAFK,EAgHJ,6DAhHI,CAAP;AAkHD,GArIH;AAuID,C","file":"PgRowByUniqueConstraint.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\nexport default (async function PgRowByUniqueConstraint(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields,\n      {\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeId,\n        pgGetGqlInputTypeByTypeId,\n        gql2pg,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: { GraphQLNonNull },\n      },\n      { scope: { isRootQuery }, fieldWithHooks }\n    ) => {\n      if (!isRootQuery) {\n        return fields;\n      }\n      return extend(\n        fields,\n        introspectionResultsByKind.class\n          .filter(table => !!table.namespace)\n          .reduce((memo, table) => {\n            const TableType = pgGetGqlTypeByTypeId(table.type.id);\n            const sqlFullTableName = sql.identifier(\n              table.namespace.name,\n              table.name\n            );\n            if (TableType) {\n              const uniqueConstraints = introspectionResultsByKind.constraint\n                .filter(con => con.classId === table.id)\n                .filter(con => con.type === \"u\" || con.type === \"p\");\n              const attributes = introspectionResultsByKind.attribute\n                .filter(attr => attr.classId === table.id)\n                .sort((a, b) => a.num - b.num);\n              uniqueConstraints.forEach(constraint => {\n                const keys = constraint.keyAttributeNums.map(\n                  num => attributes.filter(attr => attr.num === num)[0]\n                );\n                if (!keys.every(_ => _)) {\n                  throw new Error(\n                    \"Consistency error: could not find an attribute!\"\n                  );\n                }\n                const simpleKeys = keys.map(k => ({\n                  column: k.name,\n                  table: k.class.name,\n                  schema: k.class.namespace.name,\n                }));\n                const fieldName = inflection.rowByUniqueKeys(\n                  simpleKeys,\n                  table.name,\n                  table.namespace.name\n                );\n                memo[fieldName] = fieldWithHooks(\n                  fieldName,\n                  ({ getDataFromParsedResolveInfoFragment }) => {\n                    return {\n                      type: TableType,\n                      args: keys.reduce((memo, key) => {\n                        const InputType = pgGetGqlInputTypeByTypeId(key.typeId);\n                        if (!InputType) {\n                          throw new Error(\n                            `Could not find input type for key '${\n                              key.name\n                            }' on type '${TableType.name}'`\n                          );\n                        }\n                        memo[\n                          inflection.column(\n                            key.name,\n                            key.class.name,\n                            key.class.namespace.name\n                          )\n                        ] = {\n                          type: new GraphQLNonNull(InputType),\n                        };\n                        return memo;\n                      }, {}),\n                      async resolve(parent, args, { pgClient }, resolveInfo) {\n                        const parsedResolveInfoFragment = parseResolveInfo(\n                          resolveInfo\n                        );\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          TableType\n                        );\n                        const query = queryFromResolveData(\n                          sqlFullTableName,\n                          undefined,\n                          resolveData,\n                          {},\n                          builder => {\n                            keys.forEach(key => {\n                              builder.where(\n                                sql.fragment`${builder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )} = ${gql2pg(\n                                  args[\n                                    inflection.column(\n                                      key.name,\n                                      key.class.name,\n                                      key.class.namespace.name\n                                    )\n                                  ],\n                                  key.type\n                                )}`\n                              );\n                            });\n                          }\n                        );\n                        const { text, values } = sql.compile(query);\n                        if (debugSql.enabled) debugSql(text);\n                        const { rows: [row] } = await pgClient.query(\n                          text,\n                          values\n                        );\n                        return row;\n                      },\n                    };\n                  },\n                  {\n                    isPgRowByUniqueConstraintField: true,\n                    pgFieldIntrospection: constraint,\n                  }\n                );\n              });\n            }\n            return memo;\n          }, {}),\n        `Adding \"row by unique constraint\" fields to root Query type`\n      );\n    }\n  );\n}: Plugin);\n"]}