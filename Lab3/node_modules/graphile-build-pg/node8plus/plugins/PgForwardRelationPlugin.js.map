{"version":3,"sources":["../../src/plugins/PgForwardRelationPlugin.js"],"names":["debug","PgForwardRelationPlugin","builder","pgInflection","inflection","hook","fields","extend","getAliasFromResolveInfo","pgGetGqlTypeByTypeId","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","scope","isPgRowType","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","Self","table","kind","namespace","foreignKeyConstraints","constraint","filter","con","type","classId","id","attributes","attribute","attr","sort","a","b","num","reduce","memo","gqlTableType","tableTypeName","name","foreignTable","classById","foreignClassId","gqlForeignTableType","foreignTableTypeName","Error","foreignSchema","n","namespaceId","foreignAttributes","keys","keyAttributeNums","map","foreignKeys","foreignKeyAttributeNums","every","_","simpleKeys","k","column","class","schema","fieldName","singleRelationByKeys","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","foreignTableAlias","identifier","query","asJson","innerQueryBuilder","forEach","key","i","where","fragment","getTableAlias","alias","description","resolve","rawData","_args","_context","resolveInfo","data","pgFieldIntrospection"],"mappings":"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","file":"PgForwardRelationPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\nimport queryFromResolveData from \"../queryFromResolveData\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (function PgForwardRelationPlugin(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields,\n      {\n        extend,\n        getAliasFromResolveInfo,\n        pgGetGqlTypeByTypeId,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n      },\n      {\n        scope: {\n          isPgRowType,\n          isMutationPayload,\n          pgIntrospection,\n          pgIntrospectionTable,\n        },\n        fieldWithHooks,\n        Self,\n      }\n    ) => {\n      const table = pgIntrospectionTable || pgIntrospection;\n      if (\n        !(isPgRowType || isMutationPayload) ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace\n      ) {\n        return fields;\n      }\n      // This is a relation in which we (table) are local, and there's a foreign table\n\n      const foreignKeyConstraints = introspectionResultsByKind.constraint\n        .filter(con => con.type === \"f\")\n        .filter(con => con.classId === table.id);\n      const attributes = introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .sort((a, b) => a.num - b.num);\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          const gqlTableType = pgGetGqlTypeByTypeId(table.type.id);\n          const tableTypeName = gqlTableType.name;\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          const foreignTable =\n            introspectionResultsByKind.classById[constraint.foreignClassId];\n          const gqlForeignTableType = pgGetGqlTypeByTypeId(\n            foreignTable.type.id\n          );\n          const foreignTableTypeName = gqlForeignTableType.name;\n          if (!gqlForeignTableType) {\n            debug(\n              `Could not determine type for foreign table with id ${\n                constraint.foreignClassId\n              }`\n            );\n            return memo;\n          }\n          if (!foreignTable) {\n            throw new Error(\n              `Could not find the foreign table (constraint: ${\n                constraint.name\n              })`\n            );\n          }\n          const foreignSchema = introspectionResultsByKind.namespace.filter(\n            n => n.id === foreignTable.namespaceId\n          )[0];\n          const foreignAttributes = introspectionResultsByKind.attribute\n            .filter(attr => attr.classId === constraint.foreignClassId)\n            .sort((a, b) => a.num - b.num);\n\n          const keys = constraint.keyAttributeNums.map(\n            num => attributes.filter(attr => attr.num === num)[0]\n          );\n          const foreignKeys = constraint.foreignKeyAttributeNums.map(\n            num => foreignAttributes.filter(attr => attr.num === num)[0]\n          );\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n\n          const simpleKeys = keys.map(k => ({\n            column: k.name,\n            table: k.class.name,\n            schema: k.class.namespace.name,\n          }));\n          const fieldName = inflection.singleRelationByKeys(\n            simpleKeys,\n            foreignTable.name,\n            foreignTable.namespace.name\n          );\n\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              addDataGenerator(parsedResolveInfoFragment => {\n                return {\n                  pgQuery: queryBuilder => {\n                    queryBuilder.select(() => {\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        gqlForeignTableType\n                      );\n                      const foreignTableAlias = sql.identifier(Symbol());\n                      const query = queryFromResolveData(\n                        sql.identifier(foreignSchema.name, foreignTable.name),\n                        foreignTableAlias,\n                        resolveData,\n                        { asJson: true },\n                        innerQueryBuilder => {\n                          keys.forEach((key, i) => {\n                            innerQueryBuilder.where(\n                              sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                key.name\n                              )} = ${foreignTableAlias}.${sql.identifier(\n                                foreignKeys[i].name\n                              )}`\n                            );\n                          });\n                        }\n                      );\n                      return sql.fragment`(${query})`;\n                    }, parsedResolveInfoFragment.alias);\n                  },\n                };\n              });\n              return {\n                description: `Reads a single \\`${foreignTableTypeName}\\` that is related to this \\`${tableTypeName}\\`.`,\n                type: gqlForeignTableType, // Nullable since RLS may forbid fetching\n                resolve: (rawData, _args, _context, resolveInfo) => {\n                  const data = isMutationPayload ? rawData.data : rawData;\n                  const alias = getAliasFromResolveInfo(resolveInfo);\n                  return data[alias];\n                },\n              };\n            },\n            {\n              pgFieldIntrospection: constraint,\n            }\n          );\n          return memo;\n        }, {}),\n        `Adding forward relations to '${Self.name}'`\n      );\n    }\n  );\n}: Plugin);\n"]}