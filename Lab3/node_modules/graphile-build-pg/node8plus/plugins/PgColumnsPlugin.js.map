{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","pgInflection","inflection","hook","fields","build","context","extend","pgGetGqlTypeByTypeId","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","pg2gql","graphql","GraphQLString","getAliasFromResolveInfo","pgTweakFragmentForType","pgColumnFilter","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","Self","kind","attribute","filter","attr","classId","id","reduce","memo","fieldName","column","name","namespaceName","Error","getDataFromParsedResolveInfoFragment","addDataGenerator","ReturnType","typeId","parsedResolveInfoFragment","alias","pgQuery","queryBuilder","getSelectValueForFieldAndType","sqlFullName","type","isPgArray","ident","identifier","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","select","getTableAlias","description","isNotNull","domainIsNotNull","resolve","data","_args","_context","resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeId","isPgPatch","pgAddSubfield","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      getAliasFromResolveInfo,\n      pgTweakFragmentForType,\n      pgColumnFilter,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          /*\n            attr =\n              { kind: 'attribute',\n                classId: '6546809',\n                num: 21,\n                name: 'upstreamName',\n                description: null,\n                typeId: '6484393',\n                isNotNull: false,\n                hasDefault: false }\n            */\n          const fieldName = inflection.column(\n            attr.name,\n            table.name,\n            table.namespaceName\n          );\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              const ReturnType =\n                pgGetGqlTypeByTypeId(attr.typeId) || GraphQLString;\n              addDataGenerator(parsedResolveInfoFragment => {\n                const { alias } = parsedResolveInfoFragment;\n                return {\n                  pgQuery: queryBuilder => {\n                    const getSelectValueForFieldAndType = (\n                      sqlFullName,\n                      type\n                    ) => {\n                      if (type.isPgArray) {\n                        const ident = sql.identifier(Symbol());\n                        return sql.fragment`\n                          (\n                            case\n                            when ${sqlFullName} is null then null\n                            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n                            else\n                              (\n                                select json_agg(${getSelectValueForFieldAndType(\n                                  ident,\n                                  type.arrayItemType\n                                )})\n                                from unnest(${sqlFullName}) as ${ident}\n                              )\n                            end\n                          )\n                        `;\n                      } else if (type.type === \"c\") {\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          ReturnType\n                        );\n                        const jsonBuildObject = queryFromResolveData(\n                          sql.identifier(Symbol()), // Ignore!\n                          sqlFullName,\n                          resolveData,\n                          { onlyJsonField: true, addNullCase: true }\n                        );\n                        return jsonBuildObject;\n                      } else {\n                        return pgTweakFragmentForType(sqlFullName, type);\n                      }\n                    };\n                    queryBuilder.select(\n                      getSelectValueForFieldAndType(\n                        sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                          attr.name\n                        )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                        attr.type\n                      ),\n                      alias\n                    );\n                  },\n                };\n              });\n              return {\n                description: attr.description,\n                type: nullableIf(\n                  GraphQLNonNull,\n                  !attr.isNotNull && !attr.type.domainIsNotNull,\n                  ReturnType\n                ),\n                resolve: (data, _args, _context, resolveInfo) => {\n                  const alias = getAliasFromResolveInfo(resolveInfo);\n                  return pg2gql(data[alias], attr.type);\n                },\n              };\n            },\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to '${Self.name}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          const fieldName = inflection.column(\n            attr.name,\n            table.name,\n            table.namespaceName\n          );\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = pgAddSubfield(fieldName, attr.name, attr.type, {\n            description: attr.description,\n            type: nullableIf(\n              GraphQLNonNull,\n              isPgPatch ||\n                (!attr.isNotNull && !attr.type.domainIsNotNull) ||\n                attr.hasDefault,\n              pgGetGqlInputTypeByTypeId(attr.typeId) || GraphQLString\n            ),\n          });\n          return memo;\n        }, {}),\n      `Adding columns to input object '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}