{"version":3,"sources":["../../src/plugins/PersistentMemoizePlugin.js"],"names":["base64","str","Buffer","String","toString","base64Decode","NodePlugin","builder","nodeIdFieldName","inNodeIdFieldName","hook","build","nodeFetcherByTypeName","nodeAliasByTypeName","nodeTypeNameByAlias","extend","$$nodeType","getNodeIdForTypeAndIdentifiers","Type","identifiers","getNodeAlias","addNodeFetcherForTypeName","typeName","fetcher","Error","getNodeType","alias","getTypeByName","setNodeAlias","defineNodeInterfaceType","_","$$isQuery","newWithHooks","graphql","GraphQLNonNull","GraphQLID","GraphQLInterfaceType","getNullableType","name","description","resolveType","value","fields","type","addNodeIdToQuery","interfaces","scope","isRootQuery","parseResolveInfo","getNamedType","fieldWithHooks","resolve","node","getDataFromParsedResolveInfoFragment","args","data","context","resolveInfo","nodeId","JSON","parse","resolver","parsedResolveInfoFragment","resolveData","returnType","enumerable","configurable","e","isRootNodeField"],"mappings":"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","file":"PersistentMemoizePlugin.js","sourcesContent":["// @flow\nimport type {\n  Plugin,\n  Build,\n  DataForType,\n  Context,\n  ContextGraphQLObjectTypeFields,\n} from \"../SchemaBuilder\";\nimport type { ResolveTree } from \"graphql-parse-resolve-info\";\nimport type { GraphQLType, GraphQLInterfaceType } from \"graphql\";\nimport type { BuildExtensionQuery } from \"./QueryPlugin\";\n\nconst base64 = str => new Buffer(String(str)).toString(\"base64\");\nconst base64Decode = str => new Buffer(String(str), \"base64\").toString(\"utf8\");\n\nexport type NodeFetcher = (\n  data: mixed,\n  identifiers: Array<mixed>,\n  context: mixed,\n  parsedResolveInfoFragment: ResolveTree,\n  type: GraphQLType,\n  resolveData: DataForType\n) => {};\n\nexport type BuildExtensionNode = {|\n  nodeIdFieldName: string,\n  $$nodeType: Symbol,\n  nodeFetcherByTypeName: { [string]: NodeFetcher },\n  getNodeIdForTypeAndIdentifiers(\n    Type: GraphQLType,\n    ...identifiers: Array<mixed>\n  ): string,\n  addNodeFetcherForTypeName(typeName: string, fetcher: NodeFetcher): void,\n  getNodeAlias(typeName: string): string,\n  getNodeType(alias: string): GraphQLType,\n  setNodeAlias(typeName: string, alias: string): void,\n|};\n\nexport default (function NodePlugin(\n  builder,\n  { nodeIdFieldName: inNodeIdFieldName }\n) {\n  const nodeIdFieldName: string = inNodeIdFieldName\n    ? String(inNodeIdFieldName)\n    : \"id\";\n  builder.hook(\"build\", (build: Build): Build & BuildExtensionNode => {\n    const nodeFetcherByTypeName = {};\n    const nodeAliasByTypeName = {};\n    const nodeTypeNameByAlias = {};\n    return build.extend(build, {\n      nodeIdFieldName,\n      $$nodeType: Symbol(\"nodeType\"),\n      nodeFetcherByTypeName,\n      getNodeIdForTypeAndIdentifiers(Type, ...identifiers) {\n        return base64(\n          JSON.stringify([this.getNodeAlias(Type), ...identifiers])\n        );\n      },\n      addNodeFetcherForTypeName(typeName, fetcher) {\n        if (nodeFetcherByTypeName[typeName]) {\n          throw new Error(\"There's already a fetcher for this type\");\n        }\n        if (!fetcher) {\n          throw new Error(\"No fetcher specified\");\n        }\n        nodeFetcherByTypeName[typeName] = fetcher;\n      },\n      getNodeAlias(typeName) {\n        return nodeAliasByTypeName[typeName] || typeName;\n      },\n      getNodeType(alias) {\n        return this.getTypeByName(nodeTypeNameByAlias[alias] || alias);\n      },\n      setNodeAlias(typeName, alias) {\n        nodeAliasByTypeName[typeName] = alias;\n        nodeTypeNameByAlias[alias] = typeName;\n      },\n    });\n  });\n\n  builder.hook(\"init\", function defineNodeInterfaceType(\n    _: {},\n    {\n      $$isQuery,\n      $$nodeType,\n      getTypeByName,\n      newWithHooks,\n      graphql: {\n        GraphQLNonNull,\n        GraphQLID,\n        GraphQLInterfaceType,\n        getNullableType,\n      },\n    }: {| ...Build, ...BuildExtensionQuery, ...BuildExtensionNode |}\n  ) {\n    newWithHooks(\n      GraphQLInterfaceType,\n      {\n        name: \"Node\",\n        description: \"An object with a globally unique `ID`.\",\n        resolveType: value => {\n          if (value === $$isQuery) {\n            return getTypeByName(\"Query\");\n          } else if (value[$$nodeType]) {\n            return getNullableType(value[$$nodeType]);\n          }\n        },\n        fields: {\n          [nodeIdFieldName]: {\n            description:\n              \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n            type: new GraphQLNonNull(GraphQLID),\n          },\n        },\n      },\n      {}\n    );\n    return _;\n  });\n\n  builder.hook(\"GraphQLObjectType:interfaces\", function addNodeIdToQuery(\n    interfaces: Array<GraphQLInterfaceType>,\n    { getTypeByName },\n    { scope: { isRootQuery } }\n  ) {\n    if (!isRootQuery) {\n      return interfaces;\n    }\n    const Type = getTypeByName(\"Node\");\n    if (Type) {\n      return [...interfaces, Type];\n    } else {\n      return interfaces;\n    }\n  });\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields: {},\n      {\n        $$isQuery,\n        $$nodeType,\n        parseResolveInfo,\n        getTypeByName,\n        extend,\n        nodeFetcherByTypeName,\n        getNodeType,\n        graphql: { GraphQLNonNull, GraphQLID, getNamedType },\n      }: {| ...Build, ...BuildExtensionQuery, ...BuildExtensionNode |},\n      {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      }: {| ...Context, ...ContextGraphQLObjectTypeFields |}\n    ) => {\n      if (!isRootQuery) {\n        return fields;\n      }\n      return extend(fields, {\n        [nodeIdFieldName]: {\n          description:\n            \"The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\",\n          type: new GraphQLNonNull(GraphQLID),\n          resolve() {\n            return \"query\";\n          },\n        },\n        node: fieldWithHooks(\n          \"node\",\n          ({ getDataFromParsedResolveInfoFragment }) => ({\n            description: \"Fetches an object given its globally unique `ID`.\",\n            type: getTypeByName(\"Node\"),\n            args: {\n              [nodeIdFieldName]: {\n                description: \"The globally unique `ID`.\",\n                type: new GraphQLNonNull(GraphQLID),\n              },\n            },\n            async resolve(data, args, context, resolveInfo) {\n              const nodeId = args[nodeIdFieldName];\n              if (nodeId === \"query\") {\n                return $$isQuery;\n              }\n              try {\n                const [alias, ...identifiers] = JSON.parse(\n                  base64Decode(nodeId)\n                );\n                const Type = getNodeType(alias);\n                if (!Type) {\n                  throw new Error(\"Type not found\");\n                }\n                const resolver = nodeFetcherByTypeName[getNamedType(Type).name];\n                const parsedResolveInfoFragment = parseResolveInfo(\n                  resolveInfo,\n                  {},\n                  Type\n                );\n                const resolveData = getDataFromParsedResolveInfoFragment(\n                  parsedResolveInfoFragment,\n                  getNamedType(Type)\n                );\n                const node = await resolver(\n                  data,\n                  identifiers,\n                  context,\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  resolveData\n                );\n                Object.defineProperty(node, $$nodeType, {\n                  enumerable: false,\n                  configurable: false,\n                  value: Type,\n                });\n                return node;\n              } catch (e) {\n                return null;\n              }\n            },\n          }),\n          {\n            isRootNodeField: true,\n          }\n        ),\n      });\n    }\n  );\n}: Plugin);\n"]}