"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const base64 = str => new Buffer(String(str)).toString("base64");
const base64Decode = str => new Buffer(String(str), "base64").toString("utf8");

exports.default = function NodePlugin(builder, { nodeIdFieldName: inNodeIdFieldName }) {
  const nodeIdFieldName = inNodeIdFieldName ? String(inNodeIdFieldName) : "id";
  builder.hook("build", build => {
    const nodeFetcherByTypeName = {};
    const nodeAliasByTypeName = {};
    const nodeTypeNameByAlias = {};
    return build.extend(build, {
      nodeIdFieldName,
      $$nodeType: (0, _symbol2.default)("nodeType"),
      nodeFetcherByTypeName,
      getNodeIdForTypeAndIdentifiers(Type, ...identifiers) {
        return base64((0, _stringify2.default)([this.getNodeAlias(Type), ...identifiers]));
      },
      addNodeFetcherForTypeName(typeName, fetcher) {
        if (nodeFetcherByTypeName[typeName]) {
          throw new Error("There's already a fetcher for this type");
        }
        if (!fetcher) {
          throw new Error("No fetcher specified");
        }
        nodeFetcherByTypeName[typeName] = fetcher;
      },
      getNodeAlias(typeName) {
        return nodeAliasByTypeName[typeName] || typeName;
      },
      getNodeType(alias) {
        return this.getTypeByName(nodeTypeNameByAlias[alias] || alias);
      },
      setNodeAlias(typeName, alias) {
        nodeAliasByTypeName[typeName] = alias;
        nodeTypeNameByAlias[alias] = typeName;
      }
    }, `Adding 'Node' interface support to the Build`);
  });

  builder.hook("init", function defineNodeInterfaceType(_, {
    $$isQuery,
    $$nodeType,
    getTypeByName,
    newWithHooks,
    graphql: {
      GraphQLNonNull,
      GraphQLID,
      GraphQLInterfaceType,
      getNullableType
    }
  }) {
    newWithHooks(GraphQLInterfaceType, {
      name: "Node",
      description: "An object with a globally unique `ID`.",
      resolveType: value => {
        if (value === $$isQuery) {
          return getTypeByName("Query");
        } else if (value[$$nodeType]) {
          return getNullableType(value[$$nodeType]);
        }
      },
      fields: {
        [nodeIdFieldName]: {
          description: "A globally unique identifier. Can be used in various places throughout the system to identify this single value.",
          type: new GraphQLNonNull(GraphQLID)
        }
      }
    }, {});
    return _;
  });

  builder.hook("GraphQLObjectType:interfaces", function addNodeIdToQuery(interfaces, { getTypeByName }, { scope: { isRootQuery } }) {
    if (!isRootQuery) {
      return interfaces;
    }
    const Type = getTypeByName("Node");
    if (Type) {
      return [...interfaces, Type];
    } else {
      return interfaces;
    }
  });

  builder.hook("GraphQLObjectType:fields", (fields, {
    $$isQuery,
    $$nodeType,
    parseResolveInfo,
    getTypeByName,
    extend,
    nodeFetcherByTypeName,
    getNodeType,
    graphql: { GraphQLNonNull, GraphQLID, getNamedType }
  }, {
    scope: { isRootQuery },
    fieldWithHooks
  }) => {
    if (!isRootQuery) {
      return fields;
    }
    return extend(fields, {
      [nodeIdFieldName]: {
        description: "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.",
        type: new GraphQLNonNull(GraphQLID),
        resolve() {
          return "query";
        }
      },
      node: fieldWithHooks("node", ({ getDataFromParsedResolveInfoFragment }) => ({
        description: "Fetches an object given its globally unique `ID`.",
        type: getTypeByName("Node"),
        args: {
          [nodeIdFieldName]: {
            description: "The globally unique `ID`.",
            type: new GraphQLNonNull(GraphQLID)
          }
        },
        async resolve(data, args, context, resolveInfo) {
          const nodeId = args[nodeIdFieldName];
          if (nodeId === "query") {
            return $$isQuery;
          }
          try {
            const [alias, ...identifiers] = JSON.parse(base64Decode(nodeId));
            const Type = getNodeType(alias);
            if (!Type) {
              throw new Error("Type not found");
            }
            const resolver = nodeFetcherByTypeName[getNamedType(Type).name];
            const parsedResolveInfoFragment = parseResolveInfo(resolveInfo, {}, Type);
            const resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, getNamedType(Type));
            const node = await resolver(data, identifiers, context, parsedResolveInfoFragment, resolveInfo.returnType, resolveData);
            (0, _defineProperty2.default)(node, $$nodeType, {
              enumerable: false,
              configurable: false,
              value: Type
            });
            return node;
          } catch (e) {
            return null;
          }
        }
      }), {
        isRootNodeField: true
      })
    }, `Adding node helpers to the root Query`);
  });
};
//# sourceMappingURL=NodePlugin.js.map