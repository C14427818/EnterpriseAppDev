{"version":3,"sources":["../src/SchemaBuilder.js"],"names":["graphql","GraphQLSchema","debug","INDENT","SchemaBuilder","constructor","_busy","_watching","watchers","unwatchers","depth","hooks","build","init","GraphQLObjectType","GraphQLInputObjectType","GraphQLEnumType","_setPluginName","name","_currentPluginName","hook","hookName","fn","Error","displayName","push","applyHooks","input","context","debugStr","repeat","newObj","hookDisplayName","registerWatcher","listen","unlisten","createBuild","initialBuild","scope","filter","key","buildSchema","_generatedSchema","newWithHooks","isSchema","watchSchema","listener","_explicitSchemaListener","triggerChange","emit","on","unwatchSchema","removeListener"],"mappings":"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","file":"SchemaBuilder.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport makeNewBuild from \"./makeNewBuild\";\nimport { bindAll } from \"./utils\";\nimport * as graphql from \"graphql\";\nimport type {\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInterfaceType,\n  GraphQLObjectTypeConfig,\n} from \"graphql\";\nimport EventEmitter from \"events\";\nimport type {\n  simplifyParsedResolveInfoFragmentWithType,\n  getAliasFromResolveInfo,\n  parseResolveInfo,\n} from \"graphql-parse-resolve-info\";\nimport type { GraphQLResolveInfo } from \"graphql/type/definition\";\n\nimport type { FieldWithHooksFunction } from \"./makeNewBuild\";\nconst { GraphQLSchema } = graphql;\n\nconst debug = debugFactory(\"graphile-builder\");\n\nconst INDENT = \"  \";\n\nexport type Options = {\n  [string]: mixed,\n};\n\nexport type Plugin = (\n  builder: SchemaBuilder,\n  options: Options\n) => Promise<void> | void;\n\ntype TriggerChangeType = () => void;\n\nexport type DataForType = {\n  [string]: Array<mixed>,\n};\n\nexport type Build = {|\n  graphileBuildVersion: string,\n  graphql: *,\n  parseResolveInfo: parseResolveInfo,\n  simplifyParsedResolveInfoFragmentWithType: simplifyParsedResolveInfoFragmentWithType,\n  getAliasFromResolveInfo: getAliasFromResolveInfo,\n  resolveAlias(\n    data: {},\n    _args: mixed,\n    _context: mixed,\n    resolveInfo: GraphQLResolveInfo\n  ): string,\n  addType(type: GraphQLNamedType): void,\n  getTypeByName(typeName: string): ?GraphQLType,\n  extend<Obj1: *, Obj2: *>(base: Obj1, extra: Obj2, hint?: string): Obj1 & Obj2,\n  newWithHooks<T: GraphQLNamedType | GraphQLSchema>(\n    Class<T>,\n    spec: {},\n    scope: {},\n    returnNullOnInvalid?: boolean\n  ): ?T,\n  fieldDataGeneratorsByType: Map<*, *>, // @deprecated - use fieldDataGeneratorsByFieldNameByType instead\n  fieldDataGeneratorsByFieldNameByType: Map<*, *>,\n  fieldArgDataGeneratorsByFieldNameByType: Map<*, *>,\n|};\n\nexport type BuildExtensionQuery = {|\n  $$isQuery: Symbol,\n|};\n\nexport type Scope = {\n  [string]: mixed,\n};\n\nexport type Context = {|\n  scope: Scope,\n  type: string,\n  [string]: mixed,\n|};\n\ntype DataGeneratorFunction = () => {};\n\nexport type ContextGraphQLObjectTypeFields = {|\n  addDataGeneratorForField: (\n    fieldName: string,\n    fn: DataGeneratorFunction\n  ) => void,\n  recurseDataGeneratorsForField: (fieldName: string) => void,\n  Self: GraphQLNamedType,\n  GraphQLObjectType: GraphQLObjectTypeConfig<*, *>,\n  fieldWithHooks: FieldWithHooksFunction,\n|};\n\ntype SupportedHookTypes = {} | Build | Array<GraphQLInterfaceType>;\n\nexport type Hook<\n  Type: SupportedHookTypes,\n  BuildExtensions: *,\n  ContextExtensions: *\n> = (\n  input: Type,\n  build: { ...Build, ...BuildExtensions },\n  context: { ...Context, ...ContextExtensions }\n) => Type;\n\nexport type WatchUnwatch = (triggerChange: TriggerChangeType) => void;\n\nexport type SchemaListener = (newSchema: GraphQLSchema) => void;\n\nclass SchemaBuilder extends EventEmitter {\n  watchers: Array<WatchUnwatch>;\n  unwatchers: Array<WatchUnwatch>;\n  triggerChange: ?TriggerChangeType;\n  depth: number;\n  hooks: {\n    [string]: Array<Hook<*, *, *>>,\n  };\n\n  _currentPluginName: ?string;\n  _generatedSchema: ?GraphQLSchema;\n  _explicitSchemaListener: ?SchemaListener;\n  _busy: boolean;\n  _watching: boolean;\n\n  constructor() {\n    super();\n\n    this._busy = false;\n    this._watching = false;\n\n    this.watchers = [];\n    this.unwatchers = [];\n\n    // Because hooks can nest, this keeps track of how deep we are.\n    this.depth = -1;\n\n    this.hooks = {\n      // The build object represents the current schema build and is passed to\n      // all hooks, hook the 'build' event to extend this object:\n      build: [],\n\n      // 'build' phase should not generate any GraphQL objects (because the\n      // build object isn't finalised yet so it risks weirdness occurring); so\n      // if you need to set up any global types you can do so here.\n      init: [],\n\n      // Add 'query', 'mutation' or 'subscription' types in this hook:\n      GraphQLSchema: [],\n\n      // When creating a GraphQLObjectType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLObjectType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLObjectType:interfaces' to add additional interfaces to this object type\n      // - 'GraphQLObjectType:fields' to add additional fields to this object type (is\n      //   ran asynchronously and gets a reference to the final GraphQL Object as\n      //   `Self` in the context)\n      // - 'GraphQLObjectType:fields:field' to customise an individual field from above\n      // - 'GraphQLObjectType:fields:field:args' to customize the arguments to a field\n      GraphQLObjectType: [],\n      \"GraphQLObjectType:interfaces\": [],\n      \"GraphQLObjectType:fields\": [],\n      \"GraphQLObjectType:fields:field\": [],\n      \"GraphQLObjectType:fields:field:args\": [],\n\n      // When creating a GraphQLInputObjectType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLInputObjectType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLInputObjectType:fields' to add additional fields to this object type (is\n      //   ran asynchronously and gets a reference to the final GraphQL Object as\n      //   `Self` in the context)\n      // - 'GraphQLInputObjectType:fields:field' to customise an individual field from above\n      GraphQLInputObjectType: [],\n      \"GraphQLInputObjectType:fields\": [],\n      \"GraphQLInputObjectType:fields:field\": [],\n\n      // When creating a GraphQLEnumType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLEnumType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLEnumType:values' to add additional values\n      // - 'GraphQLEnumType:values:value' to change an individual value\n      GraphQLEnumType: [],\n      \"GraphQLEnumType:values\": [],\n      \"GraphQLEnumType:values:value\": [],\n    };\n  }\n\n  _setPluginName(name: ?string) {\n    this._currentPluginName = name;\n  }\n\n  /*\n   * Every hook `fn` takes three arguments:\n   * - obj - the object currently being inspected\n   * - build - the current build object (which contains a number of utilities and the context of the build)\n   * - context - information specific to the current invocation of the hook\n   *\n   * The function must either return a replacement object for `obj` or `obj` itself\n   */\n  hook<T: *>(hookName: string, fn: Hook<T, *, *>) {\n    if (!this.hooks[hookName]) {\n      throw new Error(`Sorry, '${hookName}' is not a supported hook`);\n    }\n    if (this._currentPluginName && !fn.displayName) {\n      fn.displayName = `${\n        this._currentPluginName\n      }/${hookName}/${fn.displayName || fn.name || \"anonymous\"}`;\n    }\n    this.hooks[hookName].push(fn);\n  }\n\n  applyHooks<T: *, Context>(\n    build: { ...Build },\n    hookName: string,\n    input: T,\n    context: Context,\n    debugStr: string = \"\"\n  ): T {\n    if (!input) {\n      throw new Error(\"applyHooks was called with falsy input\");\n    }\n    this.depth++;\n    try {\n      debug(`${INDENT.repeat(this.depth)}[${hookName}${debugStr}]: Running...`);\n\n      const hooks: Array<Hook<T, *, *>> = this.hooks[hookName];\n      if (!hooks) {\n        throw new Error(`Sorry, '${hookName}' is not a registered hook`);\n      }\n\n      let newObj = input;\n      for (const hook: Hook<T, *, *> of hooks) {\n        this.depth++;\n        try {\n          const hookDisplayName = hook.displayName || hook.name || \"anonymous\";\n          debug(\n            `${INDENT.repeat(\n              this.depth\n            )}[${hookName}${debugStr}]:   Executing '${hookDisplayName}'`\n          );\n          newObj = hook(newObj, build, context);\n          if (!newObj) {\n            throw new Error(\n              `Hook '${hook.displayName ||\n                hook.name ||\n                \"anonymous\"}' for '${hookName}' returned falsy value '${newObj}'`\n            );\n          }\n          debug(\n            `${INDENT.repeat(\n              this.depth\n            )}[${hookName}${debugStr}]:   '${hookDisplayName}' complete`\n          );\n        } finally {\n          this.depth--;\n        }\n      }\n\n      debug(`${INDENT.repeat(this.depth)}[${hookName}${debugStr}]: Complete`);\n\n      return newObj;\n    } finally {\n      this.depth--;\n    }\n  }\n\n  registerWatcher(listen: WatchUnwatch, unlisten: WatchUnwatch) {\n    if (!listen || !unlisten) {\n      throw new Error(\"You must provide both a listener and an unlistener\");\n    }\n    this.watchers.push(listen);\n    this.unwatchers.push(unlisten);\n  }\n\n  createBuild(): { ...Build } {\n    const initialBuild = makeNewBuild(this);\n    const build = this.applyHooks(initialBuild, \"build\", initialBuild, {\n      scope: {},\n    });\n    // Bind all functions so they can be dereferenced\n    bindAll(\n      build,\n      Object.keys(build).filter(key => typeof build[key] === \"function\")\n    );\n    Object.freeze(build);\n    this.applyHooks(build, \"init\", {}, { scope: {} });\n    return build;\n  }\n\n  buildSchema(): GraphQLSchema {\n    if (!this._generatedSchema) {\n      const build = this.createBuild();\n      this._generatedSchema = build.newWithHooks(\n        GraphQLSchema,\n        {},\n        { isSchema: true }\n      );\n    }\n    if (!this._generatedSchema) {\n      throw new Error(\"Schema generation failed\");\n    }\n    return this._generatedSchema;\n  }\n\n  async watchSchema(listener: SchemaListener) {\n    if (this._watching || this._busy) {\n      throw new Error(\"We're already watching this schema!\");\n    }\n    try {\n      this._busy = true;\n      this._watching = true;\n      this._explicitSchemaListener = listener;\n      this.triggerChange = () => {\n        this._generatedSchema = null;\n        // XXX: optionally debounce\n        this.emit(\"schema\", this.buildSchema());\n      };\n      if (listener) {\n        this.on(\"schema\", listener);\n      }\n      for (const fn of this.watchers) {\n        await fn(this.triggerChange);\n      }\n      this.emit(\"schema\", this.buildSchema());\n    } finally {\n      this._busy = false;\n    }\n  }\n\n  async unwatchSchema() {\n    if (!this._watching || this._busy) {\n      throw new Error(\"We're not watching this schema!\");\n    }\n    this._busy = true;\n    try {\n      const listener = this._explicitSchemaListener;\n      this._explicitSchemaListener = null;\n      if (listener) {\n        this.removeListener(\"schema\", listener);\n      }\n      if (this.triggerChange) {\n        for (const fn of this.unwatchers) {\n          await fn(this.triggerChange);\n        }\n      }\n      this.triggerChange = null;\n      this._watching = false;\n    } finally {\n      this._busy = false;\n    }\n  }\n}\n\nexport default SchemaBuilder;\n"]}